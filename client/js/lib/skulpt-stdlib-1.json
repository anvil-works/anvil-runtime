{
  "src/lib/_random.js": "'use strict';var MersenneTwister=function(e){void 0==e&&(e=(new Date).getTime());this.N=624;this.M=397;this.MATRIX_A=2567483615;this.UPPER_MASK=2147483648;this.LOWER_MASK=2147483647;this.mt=Array(this.N);this.mti=this.N+1;this.init_genrand(e)};\nMersenneTwister.prototype.init_genrand=function(e){this.mt[0]=e>>>0;for(this.mti=1;this.mti<this.N;this.mti++)e=this.mt[this.mti-1]^this.mt[this.mti-1]>>>30,this.mt[this.mti]=(1812433253*((e&4294901760)>>>16)<<16)+1812433253*(e&65535)+this.mti,this.mt[this.mti]>>>=0};\nMersenneTwister.prototype.init_by_array=function(e,d){var f;this.init_genrand(19650218);var h=1;var l=0;for(f=this.N>d?this.N:d;f;f--){var a=this.mt[h-1]^this.mt[h-1]>>>30;this.mt[h]=(this.mt[h]^(1664525*((a&4294901760)>>>16)<<16)+1664525*(a&65535))+e[l]+l;this.mt[h]>>>=0;h++;l++;h>=this.N&&(this.mt[0]=this.mt[this.N-1],h=1);l>=d&&(l=0)}for(f=this.N-1;f;f--)a=this.mt[h-1]^this.mt[h-1]>>>30,this.mt[h]=(this.mt[h]^(1566083941*((a&4294901760)>>>16)<<16)+1566083941*(a&65535))-h,this.mt[h]>>>=0,h++,h>=\nthis.N&&(this.mt[0]=this.mt[this.N-1],h=1);this.mt[0]=2147483648};\nMersenneTwister.prototype.genrand_int32=function(){var e=[0,this.MATRIX_A];if(this.mti>=this.N){var d;this.mti==this.N+1&&this.init_genrand(5489);for(d=0;d<this.N-this.M;d++){var f=this.mt[d]&this.UPPER_MASK|this.mt[d+1]&this.LOWER_MASK;this.mt[d]=this.mt[d+this.M]^f>>>1^e[f&1]}for(;d<this.N-1;d++)f=this.mt[d]&this.UPPER_MASK|this.mt[d+1]&this.LOWER_MASK,this.mt[d]=this.mt[d+(this.M-this.N)]^f>>>1^e[f&1];f=this.mt[this.N-1]&this.UPPER_MASK|this.mt[0]&this.LOWER_MASK;this.mt[this.N-1]=this.mt[this.M-\n1]^f>>>1^e[f&1];this.mti=0}f=this.mt[this.mti++];f^=f>>>11;f^=f<<7&2636928640;f^=f<<15&4022730752;return(f^f>>>18)>>>0};MersenneTwister.prototype.genrand_int31=function(){return this.genrand_int32()>>>1};MersenneTwister.prototype.genrand_real1=function(){return this.genrand_int32()*(1/4294967295)};MersenneTwister.prototype.random=function(){return this.genrand_int32()*(1/4294967296)};MersenneTwister.prototype.genrand_real3=function(){return(this.genrand_int32()+.5)*(1/4294967296)};\nMersenneTwister.prototype.genrand_res53=function(){var e=this.genrand_int32()>>>5,d=this.genrand_int32()>>>6;return 1.1102230246251565E-16*(67108864*e+d)};\nvar $builtinmodule=function(e){e={};var d=new MersenneTwister,f=void 0;e.seed=new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"seed\",arguments.length,0,1);a=Sk.builtin.asnum$(a);d=0<arguments.length?new MersenneTwister(a):new MersenneTwister;return Sk.builtin.none.none$});e.random=new Sk.builtin.func(function(){Sk.builtin.pyCheckArgsLen(\"random\",arguments.length,0,0);return new Sk.builtin.float_(d.genrand_res53())});var h=function(a,b,c){if(!Sk.builtin.checkInt(a))throw new Sk.builtin.ValueError(\"non-integer first argument for randrange()\");\nif(void 0===b)return a=d.genrand_res53()*a|0,new Sk.builtin.int_(a);if(!Sk.builtin.checkInt(b))throw new Sk.builtin.ValueError(\"non-integer stop for randrange()\");void 0===c&&(c=1);var g=b-a;if(1==c&&0<g)return a+=d.genrand_res53()*g|0,new Sk.builtin.int_(a);if(1==c)throw new Sk.builtin.ValueError(\"empty range for randrange() (\"+a+\", \"+b+\", \"+g+\")\");if(!Sk.builtin.checkInt(c))throw new Sk.builtin.ValueError(\"non-integer step for randrange()\");if(0<c)b=(g+c-1)/c|0;else if(0>c)b=(g+c+1)/c|0;else throw new Sk.builtin.ValueError(\"zero step for randrange()\");\nif(0>=b)throw new Sk.builtin.ValueError(\"empty range for randrange()\");a+=c*(d.genrand_res53()*b|0);return new Sk.builtin.int_(a)};e.randint=new Sk.builtin.func(function(a,b){Sk.builtin.pyCheckArgsLen(\"randint\",arguments.length,2,2);a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);return h(a,b+1)});e.randrange=new Sk.builtin.func(function(a,b,c){Sk.builtin.pyCheckArgsLen(\"randrange\",arguments.length,1,3);a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);c=Sk.builtin.asnum$(c);return h(a,b,c)});e.uniform=\nnew Sk.builtin.func(function(a,b){Sk.builtin.pyCheckArgsLen(\"uniform\",arguments.length,2,2);a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);var c=d.genrand_res53();return new Sk.builtin.float_(a+c*(b-a))});e.triangular=new Sk.builtin.func(function(a,b,c){Sk.builtin.pyCheckArgsLen(\"triangular\",arguments.length,2,3);Sk.builtin.pyCheckType(\"low\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"high\",\"number\",Sk.builtin.checkNumber(b));a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);if(a>b){var g=\na;a=b;b=g}void 0===c||c===Sk.builtin.none.none$?c=(b-a)/2:(Sk.builtin.pyCheckType(\"mode\",\"number\",Sk.builtin.checkNumber(c)),c=Sk.builtin.asnum$(c));g=d.genrand_res53();return new Sk.builtin.float_(g<(c-a)/(b-a)?a+Math.sqrt(g*(b-a)*(c-a)):b-Math.sqrt((1-g)*(b-a)*(b-c)))});var l=function(a,b){if(void 0!==f){var c=f;f=void 0}else{var g=d.genrand_res53();var k=d.genrand_res53();g=Math.sqrt(-2*Math.log(g));k*=2*Math.PI;c=g*Math.cos(k);f=g*Math.sin(k)}return a+b*c};e.gauss=new Sk.builtin.func(function(a,\nb){Sk.builtin.pyCheckArgsLen(\"gauss\",arguments.length,2,2);Sk.builtin.pyCheckType(\"mu\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"sigma\",\"number\",Sk.builtin.checkNumber(b));a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);return new Sk.builtin.float_(l(a,b))});e.normalvariate=e.gauss;e.lognormvariate=new Sk.builtin.func(function(a,b){Sk.builtin.pyCheckArgsLen(\"lognormvariate\",arguments.length,2,2);Sk.builtin.pyCheckType(\"mu\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"sigma\",\n\"number\",Sk.builtin.checkNumber(b));a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);return new Sk.builtin.float_(Math.exp(l(a,b)))});e.expovariate=new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"expovariate\",arguments.length,1,1);Sk.builtin.pyCheckType(\"lambd\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);var b=d.genrand_res53();return new Sk.builtin.float_(-Math.log(b)/a)});e.choice=new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"choice\",arguments.length,1,1);Sk.builtin.pyCheckType(\"seq\",\n\"sequence\",Sk.builtin.checkSequence(a));if(void 0!==a.sq$length){var b=new Sk.builtin.int_(d.genrand_res53()*a.sq$length()|0);return a.mp$subscript(b)}throw new Sk.builtin.TypeError(\"object has no length\");});e.shuffle=new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"shuffle\",arguments.length,1,1);Sk.builtin.pyCheckType(\"x\",\"sequence\",Sk.builtin.checkSequence(a));if(a.constructor===Sk.builtin.list){const k=a.v;for(var b=k.length-1;0<b;--b){var c=d.genrand_res53()*(b+1)|0,g=k[c];k[c]=k[b];\nk[b]=g}}else if(void 0!==a.sq$length)if(void 0!==a.mp$ass_subscript)for(b=a.sq$length()-1;0<b;--b)c=new Sk.builtin.int_(d.genrand_res53()*(b+1)|0),b=new Sk.builtin.int_(b),g=a.mp$subscript(c),a.mp$ass_subscript(c,a.mp$subscript(b)),a.mp$ass_subscript(b,g);else throw new Sk.builtin.TypeError(\"object is immutable\");else throw new Sk.builtin.TypeError(\"object has no length\");return Sk.builtin.none.none$});e.sample=new Sk.builtin.func(function(a,b){var c;Sk.builtin.pyCheckArgsLen(\"sample\",arguments.length,\n2,2);Sk.builtin.pyCheckType(\"population\",\"iterable\",Sk.builtin.checkIterable(a));Sk.builtin.pyCheckType(\"k\",\"integer\",Sk.builtin.checkInt(b));b=Sk.builtin.asnum$(b);var g=[];var k=Sk.abstr.iter(a);var m=0;for(c=k.tp$iternext();void 0!==c;m++,c=k.tp$iternext()){var n=Math.floor(d.genrand_res53()*(m+1));m<b?(n<m&&(g[m]=g[n]),g[n]=c):n<b&&(g[n]=c)}if(m<b)throw new Sk.builtin.ValueError(\"sample larger than population\");return new Sk.builtin.list(g)});return e};\n",
  "src/lib/bisect.py": "\"\"\"Bisection algorithms.\"\"\"\n\ndef insort_right(a, x, lo=0, hi=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the right of the rightmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if x < a[mid]: hi = mid\n        else: lo = mid+1\n    a.insert(lo, x)\n\ndef bisect_right(a, x, lo=0, hi=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e <= x, and all e in\n    a[i:] have e > x.  So if x already appears in the list, a.insert(x) will\n    insert just after the rightmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if x < a[mid]: hi = mid\n        else: lo = mid+1\n    return lo\n\ndef insort_left(a, x, lo=0, hi=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the left of the leftmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x: lo = mid+1\n        else: hi = mid\n    a.insert(lo, x)\n\n\ndef bisect_left(a, x, lo=0, hi=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e < x, and all e in\n    a[i:] have e >= x.  So if x already appears in the list, a.insert(x) will\n    insert just before the leftmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x: lo = mid+1\n        else: hi = mid\n    return lo\n\n# Overwrite above definitions with a fast C implementation\ntry:\n    from _bisect import *\nexcept ImportError:\n    pass\n\n# Create aliases\nbisect = bisect_right\ninsort = insort_right\n",
  "src/lib/collections.js": "'use strict';function $builtinmodule(l){const p={};return Sk.misceval.chain(Sk.importModule(\"keyword\",!1,!0),q=>{p._iskeyword=q.$d.iskeyword;return Sk.importModule(\"itertools\",!1,!0)},q=>{p._chain=q.$d.chain;p._starmap=q.$d.starmap;p._repeat=q.$d.repeat;return Sk.importModule(\"operator\",!1,!0)},q=>{p._itemgetter=q.$d.itemgetter},()=>collections_mod(p))}\nfunction collections_mod(l){function p(a){return function(c){if(void 0!==c&&!(c instanceof l.Counter))return Sk.builtin.NotImplemented.NotImplemented$;const b=new l.Counter;a.call(this,b,c);return b}}function q(a,c){return function(b){if(!(b instanceof Sk.builtin.dict))throw new Sk.builtin.TypeError(\"Counter \"+a+\"= \"+Sk.abstr.typeName(b)+\" is not supported\");c.call(this,b);return this.keep$positive()}}function u(a,c,b,d,e){function g(k,h){return k.prototype.tp$new(Sk.misceval.arrayFromIterable(h))}\nfunction n(k){const h=[];for(let t=0;t<k._fields.v.length;t++)h.push(k._fields.v[t]),h.push(k.v[t]);return new Sk.builtin.dict(h)}function m(k,h){k=new Sk.builtin.dict(k);const t=k.tp$getattr(new Sk.builtin.str(\"pop\")),A=Sk.abstr.gattr(h,new Sk.builtin.str(\"_make\")),x=Sk.misceval.callsimArray;h=x(A,[x(Sk.builtin.map_,[t,y,h])]);if(k.sq$length())throw k=k.sk$asarray(),new Sk.builtin.ValueError(\"Got unexpectd field names: [\"+k.map(B=>\"'\"+B.$jsstr()+\"'\")+\"]\");return h}a=a.tp$str();if(Sk.misceval.isTrue(Sk.misceval.callsimArray(l._iskeyword,\n[a])))throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: '\"+Sk.misceval.objectRepr(a)+\"'\");a=a.$jsstr();if(C.test(a)||!w.test(a)||!a)throw new Sk.builtin.ValueError(\"Type names and field names must be valid identifiers: '\"+a+\"'\");let f,r;if(Sk.builtin.checkString(c))f=c.$jsstr().replace(D,\" \").split(E),1==f.length&&\"\"===f[0]&&(f=[]),r=f.map(k=>new Sk.builtin.str(k));else{f=[];r=[];for(let k=Sk.abstr.iter(c),h=k.tp$iternext();void 0!==h;h=k.tp$iternext())h=h.tp$str(),\nr.push(h),f.push(h.$jsstr())}c=new Set;if(Sk.misceval.isTrue(b))for(b=0;b<f.length;b++){if(Sk.misceval.isTrue(Sk.misceval.callsimArray(l._iskeyword,[r[b]]))||z.test(f[b])||!w.test(f[b])||!f[b]||c.has(f[b]))f[b]=\"_\"+b,r[b]=new Sk.builtin.str(\"_\"+b);c.add(f[b])}else for(b=0;b<f.length;b++){if(Sk.misceval.isTrue(Sk.misceval.callsimArray(l._iskeyword,[r[b]])))throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: '\"+f[b]+\"'\");if(z.test(f[b]))throw new Sk.builtin.ValueError(\"Field names cannot start with an underscore: '\"+\nf[b]+\"'\");if(!w.test(f[b])||!f[b])throw new Sk.builtin.ValueError(\"Type names and field names must be valid identifiers: '\"+f[b]+\"'\");if(c.has(f[b]))throw new Sk.builtin.ValueError(\"Encountered duplicate field name: '\"+f[b]+\"'\");c.add(f[b])}const y=new Sk.builtin.tuple(r);b=[];let v=[];if(!Sk.builtin.checkNone(d)){v=Sk.misceval.arrayFromIterable(d);if(v.length>f.length)throw new Sk.builtin.TypeError(\"Got more default values than field names\");for(let k=0,h=r.length-v.length;h<r.length;k++,h++)b.push(r[h]),\nb.push(v[k])}d=new Sk.builtin.dict(b);g.co_varnames=[\"_cls\",\"iterable\"];n.co_varnames=[\"self\"];m.co_kwargs=1;m.co_varnames=[\"_self\"];b={};for(c=0;c<f.length;c++)b[r[c].$mangled]=new Sk.builtin.property(new l._itemgetter([new Sk.builtin.int_(c)]),void 0,void 0,new Sk.builtin.str(\"Alias for field number \"+c));return Sk.abstr.buildNativeClass(a,{constructor:function(){},base:Sk.builtin.tuple,slots:{tp$doc:a+\"(\"+f.join(\", \")+\")\",tp$new(k,h){k=Sk.abstr.copyKeywordsToNamedArgs(\"__new__\",f,k,h,v);h=new this.constructor;\nSk.builtin.tuple.call(h,k);return h},$r(){const k=this.v.map((h,t)=>f[t]+\"=\"+Sk.misceval.objectRepr(h));return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+k.join(\", \")+\")\")}},flags:{sk$klass:!0},proto:Object.assign({__module__:Sk.builtin.checkNone(e)?Sk.globals.__name__:e,__slots__:new Sk.builtin.tuple,_fields:y,_field_defaults:d,_make:new Sk.builtin.classmethod(new Sk.builtin.func(g)),_asdict:new Sk.builtin.func(n),_replace:new Sk.builtin.func(m)},b)})}l.__all__=new Sk.builtin.list([\"deque\",\"defaultdict\",\n\"namedtuple\",\"Counter\",\"OrderedDict\"].map(a=>new Sk.builtin.str(a)));l.defaultdict=Sk.abstr.buildNativeClass(\"collections.defaultdict\",{constructor:function(a,c){this.default_factory=a;Sk.builtin.dict.call(this,c)},base:Sk.builtin.dict,methods:{copy:{$meth(){return this.$copy()},$flags:{NoArgs:!0}},__copy__:{$meth(){return this.$copy()},$flags:{NoArgs:!0}},__missing__:{$meth(a){if(Sk.builtin.checkNone(this.default_factory))throw new Sk.builtin.KeyError(Sk.misceval.objectRepr(a));{const c=Sk.misceval.callsimArray(this.default_factory,\n[]);this.mp$ass_subscript(a,c);return c}},$flags:{OneArg:!0}}},getsets:{default_factory:{$get(){return this.default_factory},$set(a){this.default_factory=a=a||Sk.builtin.none.none$}}},slots:{tp$doc:\"defaultdict(default_factory[, ...]) --\\x3e dict with default factory\\n\\nThe default factory is called without arguments to produce\\na new value when a key is not present, in __getitem__ only.\\nA defaultdict compares equal to a dict with the same items.\\nAll remaining arguments are treated the same as if they were\\npassed to the dict constructor, including keyword arguments.\\n\",\ntp$init(a,c){const b=a.shift();if(void 0===b)this.default_factory=Sk.builtin.none.none$;else if(Sk.builtin.checkCallable(b)||Sk.builtin.checkNone(b))this.default_factory=b;else throw new Sk.builtin.TypeError(\"first argument must be callable\");return Sk.builtin.dict.prototype.tp$init.call(this,a,c)},$r(){const a=Sk.misceval.objectRepr(this.default_factory),c=Sk.builtin.dict.prototype.$r.call(this).v;return new Sk.builtin.str(\"defaultdict(\"+a+\", \"+c+\")\")}},proto:{$copy(){const a=[];Sk.misceval.iterFor(Sk.abstr.iter(this),\nc=>{a.push(c);a.push(this.mp$subscript(c))});return new l.defaultdict(this.default_factory,a)}}});l.Counter=Sk.abstr.buildNativeClass(\"Counter\",{constructor:function(){this.$d=new Sk.builtin.dict;Sk.builtin.dict.apply(this)},base:Sk.builtin.dict,methods:{elements:{$flags:{NoArgs:!0},$meth(){const a=l._chain.tp$getattr(new Sk.builtin.str(\"from_iterable\")),c=Sk.misceval.callsimArray;return c(a,[c(l._starmap,[l._repeat,c(this.tp$getattr(this.str$items))])])}},most_common:{$flags:{NamedArgs:[\"n\"],Defaults:[Sk.builtin.none.none$]},\n$meth(a){var c=this.sq$length();Sk.builtin.checkNone(a)?a=c:(a=Sk.misceval.asIndexOrThrow(a),a=a>c?c:0>a?0:a);c=this.$items().sort((b,d)=>Sk.misceval.richCompareBool(b[1],d[1],\"Lt\")?1:Sk.misceval.richCompareBool(b[1],d[1],\"Gt\")?-1:0);return new Sk.builtin.list(c.slice(0,a).map(b=>new Sk.builtin.tuple(b)))}},update:{$flags:{FastCall:!0},$meth(a,c){Sk.abstr.checkArgsLen(\"update\",a,0,1);return this.counter$update(a,c)}},subtract:{$flags:{FastCall:!0},$meth(a,c){Sk.abstr.checkArgsLen(\"subtract\",a,0,1);\na=a[0];if(void 0!==a)if(a instanceof Sk.builtin.dict)for(let d=Sk.abstr.iter(a),e=d.tp$iternext();void 0!==e;e=d.tp$iternext()){var b=this.mp$subscript(e);this.mp$ass_subscript(e,Sk.abstr.numberBinOp(b,a.mp$subscript(e),\"Sub\"))}else for(let d=Sk.abstr.iter(a),e=d.tp$iternext();void 0!==e;e=d.tp$iternext())a=this.mp$subscript(e),this.mp$ass_subscript(e,Sk.abstr.numberBinOp(a,this.$one,\"Sub\"));c=c||[];for(a=0;a<c.length;a+=2){b=new Sk.builtin.str(c[a]);const d=this.mp$subscript(b);this.mp$ass_subscript(b,\nSk.abstr.numberBinOp(d,c[a+1],\"Sub\"))}return Sk.builtin.none.none$}},__missing__:{$meth(a){return this.$zero},$flags:{OneArg:!0}},copy:{$meth(){return Sk.misceval.callsimArray(l.Counter,[this])},$flags:{NoArgs:!0}}},getsets:{__dict__:Sk.generic.getSetDict},slots:{tp$doc:\"Dict subclass for counting hashable items.  Sometimes called a bag\\n    or multiset.  Elements are stored as dictionary keys and their counts\\n    are stored as dictionary values.\\n\\n    >>> c = Counter('abcdeabcdabcaba')  # count elements from a string\\n\\n    >>> c.most_common(3)                # three most common elements\\n    [('a', 5), ('b', 4), ('c', 3)]\\n    >>> sorted(c)                       # list all unique elements\\n    ['a', 'b', 'c', 'd', 'e']\\n    >>> ''.join(sorted(c.elements()))   # list elements with repetitions\\n    'aaaaabbbbcccdde'\\n    >>> sum(c.values())                 # total of all counts\\n    15\\n\\n    >>> c['a']                          # count of letter 'a'\\n    5\\n    >>> for elem in 'shazam':           # update counts from an iterable\\n    ...     c[elem] += 1                # by adding 1 to each element's count\\n    >>> c['a']                          # now there are seven 'a'\\n    7\\n    >>> del c['b']                      # remove all 'b'\\n    >>> c['b']                          # now there are zero 'b'\\n    0\\n\\n    >>> d = Counter('simsalabim')       # make another counter\\n    >>> c.update(d)                     # add in the second counter\\n    >>> c['a']                          # now there are nine 'a'\\n    9\\n\\n    >>> c.clear()                       # empty the counter\\n    >>> c\\n    Counter()\\n\\n    Note:  If a count is set to zero or reduced to zero, it will remain\\n    in the counter until the entry is deleted or the counter is cleared:\\n\\n    >>> c = Counter('aaabbc')\\n    >>> c['b'] -= 2                     # reduce the count of 'b' by two\\n    >>> c.most_common()                 # 'b' is still in, but its count is zero\\n    [('a', 3), ('c', 1), ('b', 0)]\\n\\n\",\ntp$init(a,c){Sk.abstr.checkArgsLen(this.tpjs_name,a,0,1);return this.counter$update(a,c)},$r(){const a=0<this.size?Sk.builtin.dict.prototype.$r.call(this).v:\"\";return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a+\")\")},tp$as_sequence_or_mapping:!0,mp$ass_subscript(a,c){return void 0===c?this.mp$lookup(a)&&Sk.builtin.dict.prototype.mp$ass_subscript.call(this,a,c):Sk.builtin.dict.prototype.mp$ass_subscript.call(this,a,c)},tp$as_number:!0,nb$positive:p(function(a){this.$items().forEach(([c,b])=>{Sk.misceval.richCompareBool(b,\nthis.$zero,\"Gt\")&&a.mp$ass_subscript(c,b)})}),nb$negative:p(function(a){this.$items().forEach(([c,b])=>{Sk.misceval.richCompareBool(b,this.$zero,\"Lt\")&&a.mp$ass_subscript(c,Sk.abstr.numberBinOp(this.$zero,b,\"Sub\"))})}),nb$subtract:p(function(a,c){this.$items().forEach(([b,d])=>{d=Sk.abstr.numberBinOp(d,c.mp$subscript(b),\"Sub\");Sk.misceval.richCompareBool(d,this.$zero,\"Gt\")&&a.mp$ass_subscript(b,d)});c.$items().forEach(([b,d])=>{void 0===this.mp$lookup(b)&&Sk.misceval.richCompareBool(d,this.$zero,\n\"Lt\")&&a.mp$ass_subscript(b,Sk.abstr.numberBinOp(this.$zero,d,\"Sub\"))})}),nb$add:p(function(a,c){this.$items().forEach(([b,d])=>{d=Sk.abstr.numberBinOp(d,c.mp$subscript(b),\"Add\");Sk.misceval.richCompareBool(d,this.$zero,\"Gt\")&&a.mp$ass_subscript(b,d)});c.$items().forEach(([b,d])=>{void 0===this.mp$lookup(b)&&Sk.misceval.richCompareBool(d,this.$zero,\"Gt\")&&a.mp$ass_subscript(b,d)})}),nb$inplace_add:q(\"+\",function(a){a.$items().forEach(([c,b])=>{b=Sk.abstr.numberInplaceBinOp(this.mp$subscript(c),b,\n\"Add\");this.mp$ass_subscript(c,b)})}),nb$inplace_subtract:q(\"-\",function(a){a.$items().forEach(([c,b])=>{b=Sk.abstr.numberInplaceBinOp(this.mp$subscript(c),b,\"Sub\");this.mp$ass_subscript(c,b)})}),nb$or:p(function(a,c){this.$items().forEach(([b,d])=>{const e=c.mp$subscript(b);d=Sk.misceval.richCompareBool(d,e,\"Lt\")?e:d;Sk.misceval.richCompareBool(d,this.$zero,\"Gt\")&&a.mp$ass_subscript(b,d)});c.$items().forEach(([b,d])=>{void 0===this.mp$lookup(b)&&Sk.misceval.richCompareBool(d,this.$zero,\"Gt\")&&a.mp$ass_subscript(b,\nd)})}),nb$and:p(function(a,c){this.$items().forEach(([b,d])=>{const e=c.mp$subscript(b);d=Sk.misceval.richCompareBool(d,e,\"Lt\")?d:e;Sk.misceval.richCompareBool(d,this.$zero,\"Gt\")&&a.mp$ass_subscript(b,d)})}),nb$inplace_and:q(\"&\",function(a){this.$items().forEach(([c,b])=>{const d=a.mp$subscript(c);Sk.misceval.richCompareBool(d,b,\"Lt\")&&this.mp$ass_subscript(c,d)})}),nb$inplace_or:q(\"|\",function(a){a.$items().forEach(([c,b])=>{Sk.misceval.richCompareBool(b,this.mp$subscript(c),\"Gt\")&&this.mp$ass_subscript(c,\nb)})}),nb$reflected_and:null,nb$reflected_or:null,nb$reflected_add:null,nb$reflected_subtract:null},proto:{keep$positive(){this.$items().forEach(([a,c])=>{Sk.misceval.richCompareBool(c,this.$zero,\"LtE\")&&this.mp$ass_subscript(a)});return this},$zero:new Sk.builtin.int_(0),$one:new Sk.builtin.int_(1),str$items:new Sk.builtin.str(\"items\"),counter$update(a,c){var b=a[0];if(void 0!==b)if(Sk.builtin.checkMapping(b))if(this.sq$length())for(let d=Sk.abstr.iter(b),e=d.tp$iternext();void 0!==e;e=d.tp$iternext())a=\nthis.mp$subscript(e),this.mp$ass_subscript(e,Sk.abstr.numberBinOp(a,b.mp$subscript(e),\"Add\"));else this.update$common(a,void 0,\"update\");else for(let d=Sk.abstr.iter(b),e=d.tp$iternext();void 0!==e;e=d.tp$iternext())b=this.mp$subscript(e),this.mp$ass_subscript(e,Sk.abstr.numberBinOp(b,this.$one,\"Add\"));if(c&&c.length)if(this.sq$length())for(b=0;b<c.length;b+=2){a=new Sk.builtin.str(c[b]);const d=this.mp$subscript(a);this.mp$ass_subscript(a,Sk.abstr.numberBinOp(d,c[b+1],\"Add\"))}else this.update$common([],\nc,\"update\");return Sk.builtin.none.none$}},classmethods:{fromkeys:{$meth:function(){throw new Sk.builtin.NotImplementedError(\"Counter.fromkeys() is undefined.  Use Counter(iterable) instead.\");},$flags:{MinArgs:1,MaxArgs:2}}}});l.OrderedDict=Sk.abstr.buildNativeClass(\"collections.OrderedDict\",{constructor:function(){Sk.builtin.dict.call(this)},base:Sk.builtin.dict,slots:{tp$doc:\"Dictionary that remembers insertion order\",$r(){if(this.in$repr)return new Sk.builtin.str(\"...\");this.in$repr=!0;let a=\nthis.$items().map(([c,b])=>`(${Sk.misceval.objectRepr(c)}, ${Sk.misceval.objectRepr(b)})`);a=0===a.length?\"\":\"[\"+a.join(\", \")+\"]\";this.in$repr=!1;return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a+\")\")},tp$richcompare(a,c){if(\"Eq\"!==c&&\"Ne\"!==c)return Sk.builtin.NotImplemented.NotImplemented$;if(!(a instanceof l.OrderedDict))return Sk.builtin.dict.prototype.tp$richcompare.call(this,a,c);c=\"Eq\"==c?!0:!1;const b=this.size;if(b!==a.size)return!c;a=a.$items();const d=this.$items();for(let n=0;n<\nb;n++){var e=d[n],g=a[n];const m=e[0],f=g[0];if(m!==f&&!Sk.misceval.isTrue(Sk.misceval.richCompareBool(m,f,\"Eq\")))return!c;e=e[1];g=g[1];if(e!==g&&!Sk.misceval.isTrue(Sk.misceval.richCompareBool(e,g,\"Eq\")))return!c}return c}},methods:{popitem:{$flags:{NamedArgs:[\"last\"],Defaults:[Sk.builtin.bool.true$]},$meth(a){const c=this.get$size();if(0===c)throw new Sk.builtin.KeyError(\"dictionary is empty\");const [b,d]=this.$items()[Sk.misceval.isTrue(a)?c-1:0];this.pop$item(b);return new Sk.builtin.tuple([b,\nd])}},move_to_end:{$flags:{NamedArgs:[\"key\",\"last\"],Defaults:[Sk.builtin.bool.true$]},$meth(a,c){let b;for(let d in this.entries){const e=this.entries[d][0];if(e===a||Sk.misceval.richCompareBool(e,a,\"Eq\")){b=d;break}}if(void 0===b)throw new Sk.builtin.KeyError(a);a=this.entries[b];delete this.entries[b];Sk.misceval.isTrue(c)?this.entries[b]=a:this.entries={[b]:a,...this.entries};return Sk.builtin.none.none$}}}});l.deque=Sk.abstr.buildNativeClass(\"collections.deque\",{constructor:function(a,c,b,d,e){this.head=\nb||0;this.tail=d||0;this.mask=e||1;this.maxlen=c;this.v=a||Array(2)},slots:{tp$doc:\"deque([iterable[, maxlen]]) --\\x3e deque object\\n\\nA list-like sequence optimized for data accesses near its endpoints.\",tp$hash:Sk.builtin.none.none$,tp$new:Sk.generic.new,tp$init(a,c){let [b,d]=Sk.abstr.copyKeywordsToNamedArgs(\"deque\",[\"iterable\",\"maxlen\"],a,c);if(void 0!==d&&!Sk.builtin.checkNone(d)){d=Sk.misceval.asIndexSized(d,Sk.builtin.OverflowError,\"an integer is required\");if(0>d)throw new Sk.builtin.ValueError(\"maxlen must be non-negative\");\nthis.maxlen=d}this.$clear();void 0!==b&&this.$extend(b)},tp$getattr:Sk.generic.getAttr,tp$richcompare(a,c){if(this===a&&Sk.misceval.opAllowsEquality(c))return!0;if(!(a instanceof l.deque))return Sk.builtin.NotImplemented.NotImplemented$;const b=a,d=this.v;a=a.v;const e=this.tail-this.head&this.mask,g=b.tail-b.head&b.mask;let n,m=Math.max(e,g);if(e===g)for(m=0;m<e&&m<g&&(n=Sk.misceval.richCompareBool(d[this.head+m&this.mask],a[b.head+m&b.mask],\"Eq\"),n);++m);if(m>=e||m>=g)switch(c){case \"Lt\":return e<\ng;case \"LtE\":return e<=g;case \"Eq\":return e===g;case \"NotEq\":return e!==g;case \"Gt\":return e>g;case \"GtE\":return e>=g}return\"Eq\"===c?!1:\"NotEq\"===c?!0:Sk.misceval.richCompareBool(d[this.head+m&this.mask],a[b.head+m&b.mask],c)},tp$iter(){return new F(this)},$r(){const a=[];var c=this.tail-this.head&this.mask;if(this.$entered_repr)return new Sk.builtin.str(\"[...]\");this.$entered_repr=!0;for(let b=0;b<c;b++)a.push(Sk.misceval.objectRepr(this.v[this.head+b&this.mask]));c=Sk.abstr.typeName(this);if(void 0!==\nthis.maxlen)return new Sk.builtin.str(c+\"([\"+a.filter(Boolean).join(\", \")+\"], maxlen=\"+this.maxlen+\")\");this.$entered_repr=void 0;return new Sk.builtin.str(c+\"([\"+a.filter(Boolean).join(\", \")+\"])\")},tp$as_number:!0,nb$bool(){return 0!==(this.tail-this.head&this.mask)},tp$as_sequence_or_mapping:!0,sq$contains(a){for(let c=this.tp$iter(),b=c.tp$iternext();void 0!==b;b=c.tp$iternext())if(Sk.misceval.richCompareBool(b,a,\"Eq\"))return!0;return!1},sq$concat(a){if(!(a instanceof l.deque))throw new Sk.builtin.TypeError(\"can only concatenate deque (not '\"+\nSk.abstr.typeName(a)+\"') to deque\");const c=this.$copy();for(let b=a.tp$iter(),d=b.tp$iternext();void 0!==d;d=b.tp$iternext())c.$push(d);return c},sq$length(){return this.tail-this.head&this.mask},sq$repeat(a){a=Sk.misceval.asIndexOrThrow(a,\"can't multiply sequence by non-int of type '{tp$name}'\");const c=this.tail-this.head&this.mask,b=this.$copy();let d;0>=a&&b.$clear();for(let e=1;e<a;e++)for(let g=0;g<c;g++)d=this.head+g&this.mask,b.$push(this.v[d]);return b},mp$subscript(a){a=Sk.misceval.asIndexOrThrow(a);\nconst c=this.tail-this.head&this.mask;if(a>=c||a<-c)throw new Sk.builtin.IndexError(\"deque index out of range\");return this.v[(0<=a?this.head:this.tail)+a&this.mask]},mp$ass_subscript(a,c){a=Sk.misceval.asIndexOrThrow(a);const b=this.tail-this.head&this.mask;if(a>=b||a<-b)throw new Sk.builtin.IndexError(\"deque index out of range\");void 0===c?this.del$item(a):this.set$item(a,c)},nb$inplace_add(a){this.maxlen=void 0;for(let c=Sk.abstr.iter(a),b=c.tp$iternext();void 0!==b;b=c.tp$iternext())this.$push(b);\nreturn this},nb$inplace_multiply(a){a=Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError,\"can't multiply sequence by non-int of type '{tp$name}'\");0>=a&&this.$clear();const c=this.$copy(),b=this.tail-this.head&this.mask;for(let d=1;d<a;d++)for(let e=0;e<b;e++)c.$push(this.v[this.head+e&this.mask]);this.v=c.v;this.head=c.head;this.tail=c.tail;this.mask=c.mask;return this}},methods:{append:{$meth(a){this.$push(a);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Add an element to the right side of the deque.\"},\nappendleft:{$meth(a){this.$pushLeft(a);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Add an element to the left side of the deque.\"},clear:{$meth(){this.$clear();return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove all elements from the deque.\"},__copy__:{$meth(){return this.$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return a shallow copy of a deque.\"},copy:{$meth(){return this.$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return a shallow copy of a deque.\"},\ncount:{$meth(a){const c=this.tail-this.head&this.mask;let b=0;for(let d=0;d<c;d++)Sk.misceval.richCompareBool(this.v[this.head+d&this.mask],a,\"Eq\")&&b++;return new Sk.builtin.int_(b)},$flags:{OneArg:!0},$textsig:null,$doc:\"D.count(value) -> integer -- return number of occurrences of value\"},extend:{$meth(a){this.$extend(a);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Extend the right side of the deque with elements from the iterable\"},extendleft:{$meth(a){for(let c=Sk.abstr.iter(a),\nb=c.tp$iternext();void 0!==b;b=c.tp$iternext())this.$pushLeft(b);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Extend the left side of the deque with elements from the iterable\"},index:{$meth(a,c,b){c=this.$index(a,c,b);if(void 0!==c)return new Sk.builtin.int_(c);throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(a)+\" is not in deque\");},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:\"D.index(value, [start, [stop]]) -> integer -- return first index of value.\\nRaises ValueError if the value is not present.\"},\ninsert:{$meth(a,c){a=Sk.misceval.asIndexOrThrow(a,\"integer argument expected, got {tp$name}\");var b=this.tail-this.head&this.mask;if(void 0!==this.maxlen&&b>=this.maxlen)throw new Sk.builtin.IndexError(\"deque already at its maximum size\");a>b&&(a=b);a<=-b&&(a=0);a=(0<=a?this.head:this.tail)+a&this.mask;b=this.tail;for(this.tail=this.tail+1&this.mask;b!==a;){const d=b-1&this.mask;this.v[b]=this.v[d];b=d}this.v[a]=c;this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);return Sk.builtin.none.none$},\n$flags:{MinArgs:2,MaxArgs:2},$textsig:null,$doc:\"D.insert(index, object) -- insert object before index\"},pop:{$meth(){return this.$pop()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove and return the rightmost element.\"},popleft:{$meth(){return this.$popLeft()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove and return the leftmost element.\"},remove:{$meth(a){var c=this.$index(a);if(void 0===c)throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(a)+\" is not in deque\");for(a=this.head+c&this.mask;a!==\nthis.tail;)c=a+1&this.mask,this.v[a]=this.v[c],a=c;this.tail=this.tail-1&this.mask;a=this.tail-this.head&this.mask;a<this.mask>>>1&&this.$resize(a,this.v.length>>>1)},$flags:{OneArg:!0},$textsig:null,$doc:\"D.remove(value) -- remove first occurrence of value.\"},__reversed__:{$meth(){return new G(this)},$flags:{NoArgs:!0},$textsig:null,$doc:\"D.__reversed__() -- return a reverse iterator over the deque\"},reverse:{$meth(){const a=this.head,c=this.tail,b=this.mask,d=this.tail-this.head&this.mask;for(let e=\n0;e<~~(d/2);e++){const g=c-e-1&b,n=a+e&b,m=this.v[g];this.v[g]=this.v[n];this.v[n]=m}return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:\"D.reverse() -- reverse *IN PLACE*\"},rotate:{$meth(a){a=void 0===a?1:Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError);const c=this.head,b=this.tail;if(0===a||c===b)return this;this.head=c-a&this.mask;this.tail=b-a&this.mask;if(0<a)for(var d=1;d<=a;d++){var e=b-d&this.mask;this.v[c-d&this.mask]=this.v[e];this.v[e]=void 0}else for(d=0;d>a;d--)e=\nc-d&this.mask,this.v[b-d&this.mask]=this.v[e],this.v[e]=void 0;return Sk.builtin.none.none$},$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:\"Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.\"}},classmethods:Sk.generic.classGetItem,getsets:{maxlen:{$get(){return void 0===this.maxlen?Sk.builtin.none.none$:new Sk.builtin.int_(this.maxlen)},$doc:\"maximum size of a deque or None if unbounded\"}},proto:{$clear(){this.tail=this.head=0;this.mask=1;this.v=Array(2)},$copy(){return new l.deque(this.v.slice(0),\nthis.maxlen,this.head,this.tail,this.mask)},$extend(a){for(let c=Sk.abstr.iter(a),b=c.tp$iternext();void 0!==b;b=c.tp$iternext())this.$push(b)},set$item(a,c){this.v[(0<=a?this.head:this.tail)+a&this.mask]=c},del$item(a){for(a=(0<=a?this.head:this.tail)+a&this.mask;a!==this.tail;){const c=a+1&this.mask;this.v[a]=this.v[c];a=c}a=this.tail-this.head&this.mask;this.tail=this.tail-1&this.mask;a<this.mask>>>1&&this.$resize(a,this.v.length>>>1)},$push(a){this.v[this.tail]=a;this.tail=this.tail+1&this.mask;\nthis.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);a=this.tail-this.head&this.mask;void 0!==this.maxlen&&a>this.maxlen&&this.$popLeft();return this},$pushLeft(a){this.head=this.head-1&this.mask;this.v[this.head]=a;this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);a=this.tail-this.head&this.mask;void 0!==this.maxlen&&a>this.maxlen&&this.$pop();return this},$pop(){if(this.head===this.tail)throw new Sk.builtin.IndexError(\"pop from an empty deque\");this.tail=this.tail-\n1&this.mask;const a=this.v[this.tail];this.v[this.tail]=void 0;const c=this.tail-this.head&this.mask;c<this.mask>>>1&&this.$resize(c,this.v.length>>>1);return a},$popLeft(){if(this.head===this.tail)throw new Sk.builtin.IndexError(\"pop from an empty deque\");const a=this.v[this.head];this.v[this.head]=void 0;this.head=this.head+1&this.mask;const c=this.tail-this.head&this.mask;c<this.mask>>>1&&this.$resize(c,this.v.length>>>1);return a},$resize(a,c){const b=this.head,d=this.mask;this.head=0;this.tail=\na;this.mask=c-1;if(0===b)this.v.length=c;else{c=Array(c);for(let e=0;e<a;e++)c[e]=this.v[b+e&d];this.v=c}},$index(a,c,b){var d=this.tail-this.head&this.mask;c=void 0===c?0:Sk.misceval.asIndexOrThrow(c);b=void 0===b?d:Sk.misceval.asIndexOrThrow(b);const e=this.head,g=this.mask,n=this.v;c=0<=c?c:c<-d?0:d+c;b=0<=b?b:b<-d?0:d+b;for(d=c;d<b;d++)if(n[e+d&g]===a)return d},sk$asarray(){const a=[],c=this.tail-this.head&this.mask;for(let b=0;b<c;++b)a.push(this.v[this.head+b&this.mask]);return a}}});const F=\nSk.abstr.buildIteratorClass(\"_collections._deque_iterator\",{constructor:function(a){this.$index=0;this.dq=a.v;this.$length=a.tail-a.head&a.mask;this.$head=a.head;this.$tail=a.tail;this.$mask=a.mask},iternext(){if(!(this.$index>=this.$length)){var a=(0<=this.$index?this.$head:this.$tail)+this.$index&this.$mask;this.$index++;return this.dq[a]}},methods:{__length_hint__:{$meth:function(){return new Sk.builtin.int_(this.$length-this.$index)},$flags:{NoArgs:!0}}}}),G=Sk.abstr.buildIteratorClass(\"_collections._deque_reverse_iterator\",\n{constructor:function(a){this.$index=(a.tail-a.head&a.mask)-1;this.dq=a.v;this.$head=a.head;this.$mask=a.mask},iternext(){if(!(0>this.$index)){var a=this.$head+this.$index&this.$mask;this.$index--;return this.dq[a]}},methods:{__length_hint__:Sk.generic.iterReverseLengthHintMethodDef}}),C=new RegExp(/^[0-9].*/),z=new RegExp(/^[0-9_].*/),w=new RegExp(/^\\w*$/),D=/,/g,E=/\\s+/;u.co_argcount=2;u.co_kwonlyargcount=3;u.$kwdefs=[Sk.builtin.bool.false$,Sk.builtin.none.none$,Sk.builtin.none.none$];u.co_varnames=\n[\"typename\",\"field_names\",\"rename\",\"defaults\",\"module\"];l.namedtuple=new Sk.builtin.func(u);return l};\n",
  "src/lib/functools.js": "'use strict';function $builtinmodule(){const h={};return Sk.misceval.chain(Sk.importModule(\"collections\",!1,!0),y=>{h._namedtuple=y.$d.namedtuple;return functools_mod(h)})}\nfunction functools_mod(h){function y(a){return new k(()=>{throw new ia(a+\" is not yet implemented in skulpt\");})}function M(a,b){b||(b=N);if(O(a))a=P(a,Q),0>a&&(a=0);else{if(w(a)&&ja(b)){const c=a;a=128;const d=new D(c,a,b);d.tp$setattr(R,new k(()=>z({maxsize:a,typed:b})));return n(h.update_wrapper,[d,c])}if(!S(a))throw new m(\"Expected first argument to be an integer, a callable, or None\");}return new k(c=>{const d=new D(c,a,b);d.tp$setattr(R,new k(()=>z({maxsize:a,typed:b})));return n(h.update_wrapper,\n[d,c])})}function ka(a,b){const c=T(a,b,this.typed),d=this.cache.mp$lookup(c);if(void 0!==d)return this.hits++,d;this.misses++;return x(n(this.func,a,b),e=>{this.cache.mp$ass_subscript(c,e);return e})}function la(a,b){this.misses++;return n(this.func,a,b)}function ma(a,b){const c=T(a,b,this.typed),d=this.cache.mp$lookup(c);if(void 0!==d)return{result:a}=d,U(d),E(this,d),this.hits++,a;this.misses++;return x(n(this.func,a,b),e=>{if(void 0!==this.cache.mp$lookup(c))return e;if(this.cache.get$size()<\nthis.maxsize||this.root.next===this.root){var f={key:c,result:e};this.cache.mp$ass_subscript(c,f);E(this,f);return e}f=this.root.next;U(f);if(void 0===this.cache.pop$item(f.key)){{e=this.root;const l=e.next;l.prev=e.next=f;f.prev=e;f.next=l}throw new na(\"cached item removed unexpectedly\");}f.key=c;f.result=e;this.cache.mp$ass_subscript(c,f);E(this,f);return e})}function U(a){const {prev:b,next:c}=a;b.next=a.next;c.prev=a.prev}function E(a,b){a=a.root;const c=a.prev;c.next=a.prev=b;b.prev=c;b.next=\na}function T(a,b,c){const d=a.slice(0),e=[];if(b&&b.length){d.push(oa);for(let f=0;f<b.length;f+=2){const l=b[f+1];e.push(l);d.push(new u([new g(b[f]),l]))}}if(V(c))d.push(...a.map(f=>f.ob$type),...e.map(f=>f.ob$type));else if(1===d.length&&pa.has(d[0].ob$type))return d[0];return new qa(d)}function W(a,b){a=this.arg_arr.concat(a);if(b){b=X(b);const c=this.kwdict.dict$copy();c.dict$merge(b);b=Y(c)}else b=Y(this.kwdict);return{args:a,kwargs:b}}function Z(a,b){if(1>a.length)throw new m(\"type 'partial' takes at least 1 argument\");\nlet c=a.shift();if(c instanceof this.sk$builtinBase){var d=c;c=d.fn;var e=d.arg_arr;d=d.kwdict}this.check$func(c);e&&(a=e.concat(a));b=b||[];b=X(b);d&&(e=d.dict$copy(),e.dict$merge(b),b=e);if(this.sk$builtinBase===this.constructor)return new this.constructor(c,a,b);e=new this.constructor;this.sk$builtinBase.call(e,c,a,b);return e}function aa(){if(this.in$repr)return new g(\"...\");this.in$repr=!0;const a=[r(this.fn)];this.arg_arr.forEach(b=>{a.push(r(b))});this.kwdict.$items().forEach(([b,c])=>{a.push(b.toString()+\n\"=\"+r(c))});this.in$repr=!1;return new g(this.tp$name+\"(\"+a.join(\", \")+\")\")}function p(a,b){function c(e,f){let l=A(e.tp$getattr(d),[f]);if(l===ra)return l;l=V(l);return new sa(b(l,e,f))}const d=ba[a];c.co_name=d;return c}const {object:F,int_:G,str:g,list:H,tuple:u,dict:B,none:{none$:t},bool:{false$:N},NotImplemented:{NotImplemented$:ra},bool:sa,func:k,method:ta,TypeError:m,RuntimeError:na,ValueError:ua,NotImplementedError:ia,AttributeError:ca,OverflowError:Q,checkNone:S,checkBool:ja,checkCallable:w,\ncheckClass:va}=Sk.builtin,{callsimArray:A,callsimOrSuspendArray:n,iterFor:wa,chain:x,isIndex:O,asIndexSized:P,isTrue:V,richCompareBool:q,objectRepr:r,retryOptionalSuspeionOrThrow:xa,chain:ya}=Sk.misceval,{remapToPy:z}=Sk.ffi,{checkOneArg:za,checkNoKwargs:Aa,buildNativeClass:v,setUpModuleMethods:Ba,keywordArrayFromPyDict:Y,keywordArrayToPyDict:X,objectHash:Ca,lookupSpecial:Da,copyKeywordsToNamedArgs:da,typeName:I,objectSetItem:Ea,iter:J,gattr:C}=Sk.abstr,{getSetDict:K,getAttr:ea,setAttr:Fa}=Sk.generic;\nObject.assign(h,{__name__:new g(\"functools\"),__doc__:new g(\"Tools for working with functions and callable objects\"),__all__:new H(\"update_wrapper wraps WRAPPER_ASSIGNMENTS WRAPPER_UPDATES total_ordering cmp_to_key cache lru_cache reduce partial partialmethod singledispatch singledispatchmethod cached_property\".split(\" \").map(a=>new g(a))),WRAPPER_ASSIGNMENTS:new u([\"__module__\",\"__name__\",\"__qualname__\",\"__doc__\",\"__annotations__\"].map(a=>new g(a))),WRAPPER_UPDATES:new u([new g(\"__dict__\")]),singledispatch:y(\"singledispatch\"),\nsingledispatchmethod:y(\"singledispatchmethod\")});const R=new g(\"cache_parameters\"),Ga=h._CacheInfo=A(h._namedtuple,[\"CacheInfo\",[\"hits\",\"misses\",\"maxsize\",\"currsize\"]].map(a=>z(a)),[\"module\",new g(\"functools\")]),D=v(\"functools._lru_cache_wrapper\",{constructor:function(a,b,c,d){if(!w(a))throw new m(\"the first argument must be callable\");if(S(b))d=ka,b=-1;else if(O(b))b=P(b,Q),0>b&&(b=0),d=0===b?la:ma;else throw new m(\"maxsize should be integer or None\");this.root={};this.root.prev=this.root.next=this.root;\nthis.wrapper=d;this.maxsize=b;this.typed=c;this.cache=new B([]);this.func=a;this.misses=this.hits=0;this.$d=new B([])},slots:{tp$new(a,b){const [c,d,e,f]=da(\"_lru_cache_wrapper\",[\"user_function\",\"maxsize\",\"typed\",\"cache_info_type\"],a,b);return new D(c,d,e,f)},tp$call(a,b){return this.wrapper(a,b)},tp$descr_get(a,b){return null===a?this:new ta(this,a)},tp$doc:\"Create a cached callable that wraps another function.\\n\\nuser_function:      the function being cached\\n\\nmaxsize:  0         for no caching\\n          None      for unlimited cache size\\n          n         for a bounded cache\\n\\ntyped:    False     cache f(3) and f(3.0) as identical calls\\n          True      cache f(3) and f(3.0) as distinct calls\\n\\ncache_info_type:    namedtuple class with the fields:\\n                        hits misses currsize maxsize\\n\"},\nmethods:{cache_info:{$meth(){return n(Ga,[this.hits,this.misses,-1===this.maxsize?t:this.maxsize,this.cache.get$size()].map(a=>z(a)))},$flags:{NoArgs:!0},$doc:\"Report cache statistics\"},cache_clear:{$meth(){this.hits=this.misses=0;this.root={};this.root.next=this.root.prev=this.root;return n(this.cache.tp$getattr(new g(\"clear\"),!0))},$flags:{NoArgs:!0},$doc:\"Clear the cache and cache statistics\"},__deepcopy__:{$meth(a){return this},$flags:{OneArg:!0}},__copy__:{$meth(){return this},$flags:{NoArgs:!0}}},\ngetsets:{__dict__:K}}),qa=v(\"_HachedSeq\",{base:H,constructor:function(a){this.$hashval=Ca(new u(a));H.call(this,a)},slots:{tp$hash(){return this.$hashval}}}),oa=new F,pa=new Set([G,g]);h.partial=v(\"functools.partial\",{constructor:function(a,b,c){this.fn=a;this.arg_arr=b;this.arg_tup=new u(b);this.kwdict=c;this.in$repr=!1;this.$d=new B([])},slots:{tp$new:Z,tp$call(a,b){({args:a,kwargs:b}=this.adj$args_kws(a,b));return this.fn.tp$call(a,b)},tp$doc:\"partial(func, *args, **keywords) - new function with partial application\\n    of the given arguments and keywords.\\n\",\n$r:aa,tp$getattr:ea,tp$setattr:Fa},getsets:{func:{$get(){return this.fn},$doc:\"function object to use in future partial calls\"},args:{$get(){return this.arg_tup},$doc:\"tuple of arguments to future partial calls\"},keywords:{$get(){return this.kwdict},$doc:\"dictionary of keyword arguments to future partial calls\"},__dict__:K},methods:{},classmethods:Sk.generic.classGetItem,proto:{adj$args_kws:W,check$func(a){if(!w(a))throw new m(\"the first argument must be callable\");}}});h.partialmethod=v(\"functools.partialmethod\",\n{constructor:function(a,b,c){this.fn=a;this.arg_arr=b;this.arg_tup=new u(b);this.kwdict=c},slots:{tp$new:Z,tp$doc:\"Method descriptor with partial application of the given arguments\\n    and keywords.\\n\\n    Supports wrapping existing descriptors and handles non-descriptor\\n    callables as instance methods.\\n    \",$r:aa,tp$descr_get(a,b){let c;if(this.fn.tp$descr_get){var d=this.fn.tp$descr_get(a,b);if(d!==this.fn){if(!w(d))throw new m(\"type 'partial' requires a callable\");c=new h.partial(d,this.arg_arr.slice(0),\nthis.kwdict.dict$copy());d=Da(d,this.str$self);void 0!==d&&c.tp$setattr(this.str$self,d)}}void 0===c&&(c=this.make$unbound().tp$descr_get(a,b));return c}},methods:{_make_unbound_method:{$meth(){return this.make$unbound()},$flags:{NoArgs:!0}}},classmethods:Sk.generic.classGetItem,getsets:{func:{$get(){return this.fn},$doc:\"function object to use in future partial calls\"},args:{$get(){return this.arg_tup},$doc:\"tuple of arguments to future partial calls\"},keywords:{$get(){return this.kwdict},$doc:\"dictionary of keyword arguments to future partial calls\"},\n__dict__:K},proto:{str$self:new g(\"__self__\"),make$unbound(){function a(c,d){const e=c.shift();({args:c,kwargs:d}=b.adj$args_kws(c,d));c.unshift(e);return n(b.fn,c,d)}const b=this;a.co_fastcall=!0;return new k(a)},adj$args_kws:W,check$func(a){if(!w(a)&&void 0===a.tp$descr_get)throw new m(r(a)+\" is not callable or a descriptor\");}}});const ba={__lt__:g.$lt,__le__:g.$le,__gt__:g.$gt,__ge__:g.$ge},Ha=p(\"__lt__\",(a,b,c)=>!a&&q(b,c,\"NotEq\")),Ia=p(\"__lt__\",(a,b,c)=>a||q(b,c,\"Eq\")),Ja=p(\"__lt__\",a=>!a),\nKa=p(\"__le__\",(a,b,c)=>!a||q(b,c,\"Eq\")),La=p(\"__le__\",(a,b,c)=>a&&q(b,c,\"NotEq\")),Ma=p(\"__le__\",a=>!a),Na=p(\"__gt__\",(a,b,c)=>!a&&q(b,c,\"NotEq\")),Oa=p(\"__gt__\",(a,b,c)=>a||q(b,c,\"Eq\")),Pa=p(\"__gt__\",a=>!a),Qa=p(\"__ge__\",(a,b,c)=>!a||q(b,c,\"Eq\")),Ra=p(\"__ge__\",(a,b,c)=>a&&q(b,c,\"NotEq\")),Sa=p(\"__ge__\",a=>!a),fa={__lt__:{__gt__:new k(Ha),__le__:new k(Ia),__ge__:new k(Ja)},__le__:{__ge__:new k(Ka),__lt__:new k(La),__gt__:new k(Ma)},__gt__:{__lt__:new k(Na),__ge__:new k(Oa),__le__:new k(Pa)},__ge__:{__le__:new k(Qa),\n__gt__:new k(Ra),__lt__:new k(Sa)}},Ta={__lt__:\"ob$lt\",__le__:\"ob$le\",__gt__:\"ob$gt\",__ge__:\"ob$ge\"},Ua=new g(\"get\"),ha=new F;h.cached_property=v(\"functools.cached_property\",{constructor:function(){},slots:{tp$init(a,b){za(\"cached_property\",a,b);Aa(\"cached_property\",b);this._func=a[0];this._attr=t},tp$descr_get(a,b,c){if(null==a)return this;if(this._attr===t)throw new m(\"Cannot use cached_property instance without calling __set_name__ on it.\");let d;try{d=C(a,g.$dict)}catch(e){if(e instanceof ca)throw c=\n`No '__dict__' attribute on '${I(a)}' `+`instance to cache ${r(this._attr)} property.`,new m(c);throw e;}b=C(d,Ua);b=A(b,[this._attr,ha]);if(b===ha){const e=n(this._func,[a]);b=ya(e,f=>{try{return Ea(d,this._attr,e),f}catch(l){if(l instanceof m)throw f=`The '__dict__' attribute on '${I(a)}' instance `+`does not support item assignment for caching ${r(this._attr)} property.`,new m(f);throw l;}})}return c?b:xa(b)}},getsets:{__doc__:{$get(){return this._func.tp$getattr(g.$doc)||t}}},methods:{__set_name__:{$meth(a,\nb){if(this._attr===t)this._attr=b;else if(b.toString()!==this._attr.toString())throw new m(`Cannot assign the same cached_property to two different names (${r(this._attr)} and ${r(b)})`);},$flags:{MinArgs:2,MaxArgs:2}}},classmethods:Sk.generic.classGetItem});const Va=new G(0),L=v(\"functools.KeyWrapper\",{constructor:function(a,b){this.cmp=a;this.obj=b},slots:{tp$call(a,b){[a]=da(\"K\",[\"obj\"],a,b,[]);return new L(this.cmp,a)},tp$richcompare(a,b){if(!(a instanceof L))throw new m(\"other argument must be K instance\");\nvar c=this.obj;a=a.obj;if(!c||!a)throw new ca(\"object\");c=n(this.cmp,[c,a]);return x(c,d=>q(d,Va,b))},tp$getattr:ea,tp$hash:t},getsets:{obj:{$get(){return this.obj||t},$set(a){this.obj=a},$doc:\"Value wrapped by a key function.\"}}}),Wa=new g(\"update\"),Xa=new g(\"__wrapped__\");Ba(\"functools\",h,{cache:{$meth:function(a){return n(M(t),[a])},$flags:{OneArg:!0},$doc:'Simple lightweight unbounded cache.  Sometimes called \"memoize\".',$textsig:\"($module, user_function, /)\"},lru_cache:{$meth:M,$flags:{NamedArgs:[\"maxsize\",\n\"typed\"],Defaults:[new G(128),N]},$doc:\"Least-recently-used cache decorator.\\n\\nIf *maxsize* is set to None, the LRU features are disabled and the cache\\ncan grow without bound.\\n\\nIf *typed* is True, arguments of different types will be cached separately.\\nFor example, f(3.0) and f(3) will be treated as distinct calls with\\ndistinct results.\\n\\nArguments to the cached function must be hashable.\\n\\nView the cache statistics named tuple (hits, misses, maxsize, currsize)\\nwith f.cache_info().  Clear the cache and statistics with f.cache_clear().\\nAccess the underlying function with f.__wrapped__.\\n\\nSee:  http://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\"},\ncmp_to_key:{$meth:function(a){return new L(a)},$flags:{NamedArgs:[\"mycmp\"],Defaults:[]},$doc:\"Convert a cmp= function into a key= function.\",$textsig:\"($module, cmp, /)\"},reduce:{$meth:function(a,b,c){const d=J(b);let e;c=c||d.tp$iternext(!0);return x(c,f=>{if(void 0===f)throw new m(\"reduce() of empty sequence with no initial value\");e=f;return wa(d,l=>x(n(a,[e,l]),Ya=>{e=Ya}))},()=>e)},$flags:{MinArgs:2,MaxArgs:3},$doc:\"reduce(function, sequence[, initial]) -> value\\n\\nApply a function of two arguments cumulatively to the items of a sequence,\\nfrom left to right, so as to reduce the sequence to a single value.\\nFor example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\\n((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\\nof the sequence in the calculation, and serves as a default when the\\nsequence is empty.\",\n$textsig:\"($module, function, sequence[, initial], /)\"},total_ordering:{$meth:function(a){const b=[];if(!va(a))throw new m(\"total ordering only supported for type objects not '\"+I(a)+\"'\");Object.keys(fa).forEach(c=>{const d=Ta[c];a.prototype[d]!==F.prototype[d]&&b.push(c)});if(!b.length)throw new ua(\"must define atleast one ordering operation: <, >, <=, >=\");Object.entries(fa[b[0]]).forEach(([c,d])=>{b.includes(c)||a.tp$setattr(ba[c],d)});return a},$flags:{OneArg:!0},$doc:\"Class decorator that fills in missing ordering methods\"},\nupdate_wrapper:{$meth:function(a,b,c,d){c=J(c);let e;for(let f=c.tp$iternext();void 0!==f;f=c.tp$iternext())void 0!==(e=b.tp$getattr(f))&&a.tp$setattr(f,e);c=J(d);for(d=c.tp$iternext();void 0!==d;d=c.tp$iternext())e=b.tp$getattr(d)||new B([]),d=C(a,d),d=C(d,Wa),A(d,[e]);a.tp$setattr(Xa,b);return a},$flags:{NamedArgs:[\"wrapper\",\"wrapped\",\"assigned\",\"updated\"],Defaults:[h.WRAPPER_ASSIGNMENTS,h.WRAPPER_UPDATES]},$doc:\"Update a wrapper function to look like the wrapped function\\n\\n       wrapper is the function to be updated\\n       wrapped is the original function\\n       assigned is a tuple naming the attributes assigned directly\\n       from the wrapped function to the wrapper function (defaults to\\n       functools.WRAPPER_ASSIGNMENTS)\\n       updated is a tuple naming the attributes of the wrapper that\\n       are updated with the corresponding attribute from the wrapped\\n       function (defaults to functools.WRAPPER_UPDATES)\\n    \",\n$textsig:\"($module, /, wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))\"},wraps:{$meth:function(a,b,c){return n(h.partial,[h.update_wrapper],[\"wrapped\",a,\"assigned\",b,\"updated\",c])},$flags:{NamedArgs:[\"wrapped\",\"assigned\",\"updated\"],Defaults:[h.WRAPPER_ASSIGNMENTS,h.WRAPPER_UPDATES]},$doc:\"Decorator factory to apply update_wrapper() to a wrapper function\\n\\n       Returns a decorator that invokes update_wrapper() with the decorated\\n       function as the wrapper argument and the arguments to wraps() as the\\n       remaining arguments. Default arguments are as for update_wrapper().\\n       This is a convenience function to simplify applying partial() to\\n       update_wrapper().\\n    \",\n$textsig:\"($module, /, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))\"}});return h};\n",
  "src/lib/itertools.js": "'use strict';var $builtinmodule=function(l){function g(a,b,c){[c,b]=Sk.abstr.copyKeywordsToNamedArgs(a.tp$name,[\"iterable\",\"r\"],b,c,[]);c=Sk.misceval.arrayFromIterable(c);b=Sk.misceval.asIndexSized(b,Sk.builtin.OverFlowError);if(0>b)throw new Sk.builtin.ValueError(\"r must be non-negative\");if(this===a)return new a.constructor(c,b);{const e=new this.constructor;a.constructor.call(e,c,b);return e}}var d={};d.accumulate=Sk.abstr.buildIteratorClass(\"itertools.accumulate\",{constructor:function(a,b,c){this.iter=\na;this.func=b;this.total=c;this.tp$iternext=()=>{this.total=Sk.builtin.checkNone(this.total)?this.iter.tp$iternext():this.total;this.tp$iternext=this.constructor.prototype.tp$iternext;return this.total}},iternext(a){a=this.iter.tp$iternext();if(void 0!==a)return this.total=Sk.misceval.callsimArray(this.func,[this.total,a])},slots:{tp$doc:\"accumulate(iterable[, func, initial]) --\\x3e accumulate object\\n\\nReturn series of accumulated sums (or other binary function results).\",tp$new(a,b){Sk.abstr.checkArgsLen(\"accumulate\",\na,0,2);let [c,e,f]=Sk.abstr.copyKeywordsToNamedArgs(\"accumulate\",[\"iterable\",\"func\",\"initial\"],a,b,[Sk.builtin.none.none$,Sk.builtin.none.none$]);c=Sk.abstr.iter(c);e=Sk.builtin.checkNone(e)?new Sk.builtin.func((h,k)=>Sk.abstr.numberBinOp(h,k,\"Add\")):e;if(this===d.accumulate.prototype)return new d.accumulate(c,e,f);a=new this.constructor;d.accumulate.call(a,c,e,f);return a}}});d.chain=Sk.abstr.buildIteratorClass(\"itertools.chain\",{constructor:function(a){this.iterables=a;this.current_it=null;this.tp$iternext=\n()=>{this.tp$iternext=this.constructor.prototype.tp$iternext;this.current_it=this.iterables.tp$iternext();if(void 0===this.current_it)this.tp$iternext=()=>{};else return this.current_it=Sk.abstr.iter(this.current_it),this.tp$iternext()}},iternext(a){let b;for(;void 0===b;)if(b=this.current_it.tp$iternext(),void 0===b){this.current_it=this.iterables.tp$iternext();if(void 0===this.current_it){this.tp$iternext=()=>{};break}this.current_it=Sk.abstr.iter(this.current_it)}else return b},slots:{tp$doc:\"chain(*iterables) --\\x3e chain object\\n\\nReturn a chain object whose .__next__() method returns elements from the\\nfirst iterable until it is exhausted, then elements from the next\\niterable, until all of the iterables are exhausted.\",\ntp$new(a,b){Sk.abstr.checkNoKwargs(\"chain\",b);a=(new Sk.builtin.tuple(a.slice(0))).tp$iter();if(this===d.chain.prototype)return new d.chain(a);b=new this.constructor;d.chain.call(b,a);return b}},classmethods:Object.assign({from_iterable:{$meth(a){a=Sk.abstr.iter(a);return new d.chain(a)},$flags:{OneArg:!0},$doc:\"chain.from_iterable(iterable) --\\x3e chain object\\n\\nAlternate chain() constructor taking a single iterable argument\\nthat evaluates lazily.\",$textsig:null}},Sk.generic.classGetItem)});d.combinations=\nSk.abstr.buildIteratorClass(\"itertools.combinations\",{constructor:function(a,b){this.pool=a;this.r=b;this.indices=Array(b).fill().map((c,e)=>e);this.n=a.length;this.tp$iternext=()=>{if(!(this.r>this.n))return this.tp$iternext=this.constructor.prototype.tp$iternext,new Sk.builtin.tuple(this.pool.slice(0,this.r))}},iternext(a){let b=!1;for(a=this.r-1;0<=a;a--)if(this.indices[a]!=a+this.n-this.r){b=!0;break}if(b){this.indices[a]++;for(a+=1;a<this.r;a++)this.indices[a]=this.indices[a-1]+1;a=this.indices.map(c=>\nthis.pool[c]);return new Sk.builtin.tuple(a)}this.r=0},slots:{tp$doc:\"combinations(iterable, r) --\\x3e combinations object\\n\\nReturn successive r-length combinations of elements in the iterable.\\n\\ncombinations(range(4), 3) --\\x3e (0,1,2), (0,1,3), (0,2,3), (1,2,3)\",tp$new(a,b){return g.call(this,d.combinations.prototype,a,b)}}});d.combinations_with_replacement=Sk.abstr.buildIteratorClass(\"itertools.combinations_with_replacement\",{constructor:function(a,b){this.pool=a;this.r=b;this.indices=Array(b).fill(0);\nthis.n=a.length;this.tp$iternext=()=>{if(!this.r||this.n){this.tp$iternext=this.constructor.prototype.tp$iternext;var c=this.indices.map(e=>this.pool[e]);return new Sk.builtin.tuple(c)}}},iternext(a){var b=!1;for(a=this.r-1;0<=a;a--)if(this.indices[a]!=this.n-1){b=!0;break}if(b){for(b=this.indices[a]+1;a<this.r;a++)this.indices[a]=b;a=this.indices.map(c=>this.pool[c]);return new Sk.builtin.tuple(a)}this.r=0},slots:{tp$doc:\"combinations_with_replacement(iterable, r) --\\x3e combinations_with_replacement object\\n\\nReturn successive r-length combinations of elements in the iterable\\nallowing individual elements to have successive repeats.\\ncombinations_with_replacement('ABC', 2) --\\x3e AA AB AC BB BC CC\",\ntp$new(a,b){return g.call(this,d.combinations_with_replacement.prototype,a,b)}}});d.compress=Sk.abstr.buildIteratorClass(\"itertools.compress\",{constructor:function(a,b){this.data=a;this.selectors=b},iternext(){let a=this.data.tp$iternext(),b=this.selectors.tp$iternext();for(;void 0!==a&&void 0!==b;){if(Sk.misceval.isTrue(b))return a;a=this.data.tp$iternext();b=this.selectors.tp$iternext()}},slots:{tp$doc:\"compress(data, selectors) --\\x3e iterator over selected data\\n\\nReturn data elements corresponding to true selector elements.\\nForms a shorter iterator from selected data elements using the\\nselectors to choose the data elements.\",\ntp$new(a,b){[a,b]=Sk.abstr.copyKeywordsToNamedArgs(\"compress\",[\"data\",\"selectors\"],a,b,[]);a=Sk.abstr.iter(a);b=Sk.abstr.iter(b);if(this===d.count.prototype)return new d.compress(a,b);{const c=new this.constructor;d.compress.call(c,a,b);return c}}}});d.count=Sk.abstr.buildIteratorClass(\"itertools.count\",{constructor:function(a,b){this.start=a;this.step=b},iternext(){const a=this.start;this.start=Sk.abstr.numberBinOp(this.start,this.step,\"Add\");return a},slots:{tp$doc:\"count(start=0, step=1) --\\x3e count object\\n\\nReturn a count object whose .__next__() method returns consecutive values.\\nEquivalent to:\\n\\n    def count(firstval=0, step=1):\\n        x = firstval\\n        while 1:\\n            yield x\\n            x += step\\n\",\ntp$new(a,b){const [c,e]=Sk.abstr.copyKeywordsToNamedArgs(\"count\",[\"start\",\"step\"],a,b,[new Sk.builtin.int_(0),new Sk.builtin.int_(1)]);if(!Sk.builtin.checkNumber(c)&&!Sk.builtin.checkComplex(c))throw new Sk.builtin.TypeError(\"a number is required\");if(!Sk.builtin.checkNumber(e)&&!Sk.builtin.checkComplex(e))throw new Sk.builtin.TypeError(\"a number is required\");if(this===d.count.prototype)return new d.count(c,e);a=new this.constructor;d.count.call(a,c,e);return a},$r(){const a=Sk.misceval.objectRepr(this.start);\nlet b=Sk.misceval.objectRepr(this.step);b=\"1\"===b?\"\":\", \"+b;return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a+b+\")\")}}});d.cycle=Sk.abstr.buildIteratorClass(\"itertools.cycle\",{constructor:function(a){this.iter=a;this.saved=[];this.consumed=!1;this.i=0;this.length},iternext(){let a;if(!this.consumed){a=this.iter.tp$iternext();if(void 0!==a)return this.saved.push(a),a;this.consumed=!0;this.length=this.saved.length;if(!this.length)return}a=this.saved[this.i];this.i=(this.i+1)%this.length;return a},\nslots:{tp$doc:\"cycle(iterable) --\\x3e cycle object\\n\\nReturn elements from the iterable until it is exhausted.\\nThen repeat the sequence indefinitely.\",tp$new(a,b){Sk.abstr.checkOneArg(\"cycle\",a,b);a=Sk.abstr.iter(a[0]);if(this===d.cycle.prototype)return new d.cycle(a);b=new this.constructor;d.cycle.call(b,a);return b}}});d.dropwhile=Sk.abstr.buildIteratorClass(\"itertools.dropwhile\",{constructor:function(a,b){this.predicate=a;this.iter=b;this.passed},iternext(){let a=this.iter.tp$iternext();for(;void 0===\nthis.passed&&void 0!==a;){const b=Sk.misceval.callsimArray(this.predicate,[a]);if(!Sk.misceval.isTrue(b)){this.passed=!0;break}a=this.iter.tp$iternext()}return a},slots:{tp$doc:\"dropwhile(predicate, iterable) --\\x3e dropwhile object\\n\\nDrop items from the iterable while predicate(item) is true.\\nAfterwards, return every element until the iterable is exhausted.\",tp$new(a,b){Sk.abstr.checkNoKwargs(\"dropwhile\",b);Sk.abstr.checkArgsLen(\"dropwhile\",a,2,2);b=a[0];a=Sk.abstr.iter(a[1]);if(this===d.dropwhile.prototype)return new d.dropwhile(b,\na);{const c=new this.constructor;d.dropwhile.call(c,b,a);return c}}}});d.filterfalse=Sk.abstr.buildIteratorClass(\"itertools.filterfalse\",{constructor:function(a,b){this.predicate=a;this.iter=b},iternext(a){a=this.iter.tp$iternext();if(void 0!==a){for(var b=Sk.misceval.callsimArray(this.predicate,[a]);Sk.misceval.isTrue(b);){a=this.iter.tp$iternext();if(void 0===a)return;b=Sk.misceval.callsimArray(this.predicate,[a])}return a}},slots:{tp$doc:\"filterfalse(function or None, sequence) --\\x3e filterfalse object\\n\\nReturn those items of sequence for which function(item) is false.\\nIf function is None, return the items that are false.\",\ntp$new(a,b){Sk.abstr.checkNoKwargs(\"filterfalse\",b);Sk.abstr.checkArgsLen(\"filterfalse\",a,2,2);b=Sk.builtin.checkNone(a[0])?Sk.builtin.bool:a[0];a=Sk.abstr.iter(a[1]);if(this===d.filterfalse.prototype)return new d.filterfalse(b,a);{const c=new this.constructor;d.filterfalse.call(c,b,a);return c}}}});d._grouper=Sk.abstr.buildIteratorClass(\"itertools._grouper\",{constructor:function(a,b){this.groupby=a;this.tgtkey=a.tgtkey;this.id=a.id},iternext(a){a=Sk.misceval.richCompareBool(this.groupby.currkey,\nthis.tgtkey,\"Eq\");if(this.groupby.id===this.id&&a)return a=this.groupby.currval,this.groupby.currval=this.groupby.iter.tp$iternext(),void 0!==this.groupby.currval&&(this.groupby.currkey=Sk.misceval.callsimArray(this.groupby.keyf,[this.groupby.currval])),a}});d.groupby=Sk.abstr.buildIteratorClass(\"itertools.groupby\",{constructor:function(a,b){this.iter=a;this.keyf=b;this.currval;this.currkey=this.tgtkey=new Sk.builtin.object;this.id},iternext(a){this.id={};for(a=Sk.misceval.richCompareBool(this.currkey,\nthis.tgtkey,\"Eq\");a;){this.currval=this.iter.tp$iternext();if(void 0===this.currval)return;this.currkey=Sk.misceval.callsimArray(this.keyf,[this.currval]);a=Sk.misceval.richCompareBool(this.currkey,this.tgtkey,\"Eq\")}this.tgtkey=this.currkey;a=new d._grouper(this);return new Sk.builtin.tuple([this.currkey,a])},slots:{tp$doc:\"groupby(iterable, key=None) -> make an iterator that returns consecutive\\nkeys and groups from the iterable.  If the key function is not specified or\\nis None, the element itself is used for grouping.\\n\",\ntp$new(a,b){[a,b]=Sk.abstr.copyKeywordsToNamedArgs(\"groupby\",[\"iterable\",\"key\"],a,b,[Sk.builtin.none.none$]);a=Sk.abstr.iter(a);b=Sk.builtin.checkNone(b)?new Sk.builtin.func(c=>c):b;if(this===d.groupby.prototype)return new d.groupby(a,b);{const c=new this.constructor;d.groupby.call(c,a,b);return c}}}});d.islice=Sk.abstr.buildIteratorClass(\"itertools.islice\",{constructor:function(a,b,c,e){this.iter=a;this.previt=b;this.stop=c;this.step=e;this.tp$iternext=()=>{this.tp$iternext=this.constructor.prototype.tp$iternext;\nif(this.previt>=this.stop)for(var f=0;f<this.stop;f++)this.iter.tp$iternext();else{for(f=0;f<this.previt;f++)this.iter.tp$iternext();return this.iter.tp$iternext()}}},iternext(a){if(this.previt+this.step>=this.stop)for(a=this.previt+1;a<this.stop;a++)this.previt+=this.step,this.iter.tp$iternext();else{for(a=this.previt+1;a<this.previt+this.step;a++)this.iter.tp$iternext();this.previt+=this.step;return this.iter.tp$iternext()}},slots:{tp$doc:\"islice(iterable, stop) --\\x3e islice object\\nislice(iterable, start, stop[, step]) --\\x3e islice object\\n\\nReturn an iterator whose next() method returns selected values from an\\niterable.  If start is specified, will skip all preceding elements;\\notherwise, start defaults to zero.  Step defaults to one.  If\\nspecified as another value, step determines how many values are \\nskipped between successive calls.  Works like a slice() on a list\\nbut returns an iterator.\",\ntp$new(a,b){Sk.abstr.checkNoKwargs(\"islice\",b);Sk.abstr.checkArgsLen(\"islice\",a,2,4);b=Sk.abstr.iter(a[0]);let c=a[1],e=a[2];a=a[3];void 0===e?(e=c,a=c=Sk.builtin.none.none$):void 0===a&&(a=Sk.builtin.none.none$);if(Sk.builtin.checkNone(e)||Sk.misceval.isIndex(e)){if(e=Sk.builtin.checkNone(e)?Number.MAX_SAFE_INTEGER:Sk.misceval.asIndexSized(e),0>e||e>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError(\"Stop for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");}else throw new Sk.builtin.ValueError(\"Stop for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");\nif(Sk.builtin.checkNone(c)||Sk.misceval.isIndex(c)){if(c=Sk.builtin.checkNone(c)?0:Sk.misceval.asIndexSized(c),0>c||c>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError(\"Indices for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");}else throw new Sk.builtin.ValueError(\"Indices for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");if(Sk.builtin.checkNone(a)||Sk.misceval.isIndex(a)){if(a=Sk.builtin.checkNone(a)?1:Sk.misceval.asIndexSized(a),0>=a||a>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError(\"Step for islice() must be a positive integer or None.\");\n}else throw new Sk.builtin.ValueError(\"Step for islice() must be a positive integer or None\");if(this===d.islice.prototype)return new d.islice(b,c,e,a);{const f=new this.constructor;d.islice.call(f,b,c,e,a);return f}}}});d.permutations=Sk.abstr.buildIteratorClass(\"itertools.permutations\",{constructor:function(a,b){this.pool=a;this.r=b;const c=a.length;this.indices=Array(c).fill().map((e,f)=>f);this.cycles=Array(b).fill().map((e,f)=>c-f);this.n=c;this.tp$iternext=()=>{if(!(this.r>this.n))return this.tp$iternext=\nthis.constructor.prototype.tp$iternext,new Sk.builtin.tuple(this.pool.slice(0,this.r))}},iternext(a){for(a=this.r-1;0<=a;a--)if(this.cycles[a]--,0==this.cycles[a])this.indices.push(this.indices.splice(a,1)[0]),this.cycles[a]=this.n-a;else{const b=this.cycles[a];[this.indices[a],this.indices[this.n-b]]=[this.indices[this.n-b],this.indices[a]];a=this.indices.map(c=>this.pool[c]).slice(0,this.r);return new Sk.builtin.tuple(a)}this.r=0},slots:{tp$doc:\"permutations(iterable[, r]) --\\x3e permutations object\\n\\nReturn successive r-length permutations of elements in the iterable.\\n\\npermutations(range(3), 2) --\\x3e (0,1), (0,2), (1,0), (1,2), (2,0), (2,1)\",\ntp$new(a,b){[b,a]=Sk.abstr.copyKeywordsToNamedArgs(\"permutations\",[\"iterable\",\"r\"],a,b,[Sk.builtin.none.none$]);b=Sk.misceval.arrayFromIterable(b);a=Sk.builtin.checkNone(a)?b.length:Sk.misceval.asIndexSized(a,Sk.builtin.OverFlowError);if(0>a)throw new Sk.builtin.ValueError(\"r must be non-negative\");if(this===d.permutations.prototype)return new d.permutations(b,a);{const c=new this.constructor;d.permutations.call(c,b,a);return c}}}});d.product=Sk.abstr.buildIteratorClass(\"itertools.product\",{constructor:function(a){this.pools=\na;this.n=a.length;this.indices=Array(a.length).fill(0);this.pool_sizes=a.map(b=>b.length);this.tp$iternext=()=>{this.tp$iternext=this.constructor.prototype.tp$iternext;const b=this.indices.map((c,e)=>this.pools[e][this.indices[e]]);if(b.some(c=>void 0===c))this.n=0;else return new Sk.builtin.tuple(b)}},iternext(a){for(a=this.n-1;0<=a&&a<this.n;)this.indices[a]++,this.indices[a]>=this.pool_sizes[a]?(this.indices[a]=-1,a--):a++;if(!this.n||this.indices.every(b=>-1===b))this.n=0;else return a=this.indices.map((b,\nc)=>this.pools[c][this.indices[c]]),new Sk.builtin.tuple(a)},slots:{tp$doc:\"product(*iterables, repeat=1) --\\x3e product object\\n\\nCartesian product of input iterables.  Equivalent to nested for-loops.\\n\\nFor example, product(A, B) returns the same as:  ((x,y) for x in A for y in B).\\nThe leftmost iterators are in the outermost for-loop, so the output tuples\\ncycle in a manner similar to an odometer (with the rightmost element changing\\non every iteration).\\n\\nTo compute the product of an iterable with itself, specify the number\\nof repetitions with the optional repeat keyword argument. For example,\\nproduct(A, repeat=4) means the same as product(A, A, A, A).\\n\\nproduct('ab', range(3)) --\\x3e ('a',0) ('a',1) ('a',2) ('b',0) ('b',1) ('b',2)\\nproduct((0,1), (0,1), (0,1)) --\\x3e (0,0,0) (0,0,1) (0,1,0) (0,1,1) (1,0,0) ...\",\ntp$new(a,b){[b]=Sk.abstr.copyKeywordsToNamedArgs(\"product\",[\"repeat\"],[],b,[new Sk.builtin.int_(1)]);b=Sk.misceval.asIndexSized(b,Sk.builtin.OverFlowError);if(0>b)throw new Sk.builtin.ValueError(\"repeat argument cannot be negative\");const c=[];for(let e=0;e<a.length;e++)c.push(Sk.misceval.arrayFromIterable(a[e]));a=[].concat(...Array(b).fill(c));if(this===d.product.prototype)return new d.product(a);b=new this.constructor;d.product.call(b,a);return b}}});d.repeat=Sk.abstr.buildIteratorClass(\"itertools.repeat\",\n{constructor:function(a,b){this.object=a;this.times=b;void 0===b&&(this.tp$iternext=()=>this.object)},iternext(a){return 0<this.times--?this.object:void 0},slots:{tp$doc:\"repeat(object [,times]) -> create an iterator which returns the object\\nfor the specified number of times.  If not specified, returns the object\\nendlessly.\",tp$new(a,b){[a,b]=Sk.abstr.copyKeywordsToNamedArgs(\"repeat\",[\"object\",\"times\"],a,b,[null]);b=null!==b?Sk.misceval.asIndexSized(b,Sk.builtin.OverFlowError):void 0;if(this===\nd.repeat.prototype)return new d.repeat(a,b);{const c=new this.constructor;d.repeat.call(c,a,b);return c}},$r(){const a=Sk.misceval.objectRepr(this.object),b=void 0===this.times?\"\":\", \"+(0<=this.times?this.times:0);return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a+b+\")\")}},methods:{__lenght_hint__:{$meth(){if(void 0===this.times)throw new Sk.builtin.TypeError(\"len() of unsized object\");return new Sk.builtin.int_(this.times)},$flags:{NoArgs:!0},$textsig:null}}});d.starmap=Sk.abstr.buildIteratorClass(\"itertools.starmap\",\n{constructor:function(a,b){this.func=a;this.iter=b},iternext(a){a=this.iter.tp$iternext();if(void 0!==a)return a=Sk.misceval.arrayFromIterable(a),Sk.misceval.callsimArray(this.func,a)},slots:{tp$new(a,b){[a,b]=Sk.abstr.copyKeywordsToNamedArgs(\"starmap\",[\"func\",\"iterable\"],a,b,[]);b=Sk.abstr.iter(b);a=Sk.builtin.checkNone(a)?Sk.builtin.bool:a;if(this===d.starmap.prototype)return new d.starmap(a,b);{const c=new this.constructor;d.starmap.call(c,a,b);return c}}}});d.takewhile=Sk.abstr.buildIteratorClass(\"itertools.takewhile\",\n{constructor:function(a,b){this.predicate=a;this.iter=b},iternext(){const a=this.iter.tp$iternext();if(void 0!==a){const b=Sk.misceval.callsimArray(this.predicate,[a]);if(Sk.misceval.isTrue(b))return a;this.tp$iternext=()=>{}}},slots:{tp$doc:\"takewhile(predicate, iterable) --\\x3e takewhile object\\n\\nReturn successive entries from an iterable as long as the \\npredicate evaluates to true for each entry.\",tp$new(a,b){Sk.abstr.checkNoKwargs(\"takewhile\",b);Sk.abstr.checkArgsLen(\"takewhile\",a,2,2);b=a[0];\na=Sk.abstr.iter(a[1]);if(this===d.takewhile.prototype)return new d.takewhile(b,a);{const c=new this.constructor;d.takewhile.call(c,b,a);return c}}}});d.tee=new Sk.builtin.func(function(){throw new Sk.builtin.NotImplementedError(\"tee is not yet implemented in Skulpt\");});d.zip_longest=Sk.abstr.buildIteratorClass(\"itertools.zip_longest\",{constructor:function(a,b){this.iters=a;this.fillvalue=b;this.active=this.iters.length},iternext(a){if(this.active){var b=[];for(let c=0;c<this.iters.length;c++){a=\nthis.iters[c].tp$iternext();if(void 0===a){this.active--;if(!this.active)return;this.iters[c]=new d.repeat(this.fillvalue);a=this.fillvalue}b.push(a)}return new Sk.builtin.tuple(b)}},slots:{tp$doc:\"zip_longest(iter1 [,iter2 [...]], [fillvalue=None]) --\\x3e zip_longest object\\n\\nReturn a zip_longest object whose .__next__() method returns a tuple where\\nthe i-th element comes from the i-th iterable argument.  The .__next__()\\nmethod continues until the longest iterable in the argument sequence\\nis exhausted and then it raises StopIteration.  When the shorter iterables\\nare exhausted, the fillvalue is substituted in their place.  The fillvalue\\ndefaults to None or can be specified by a keyword argument.\\n\",\ntp$new(a,b){[b]=Sk.abstr.copyKeywordsToNamedArgs(\"zip_longest\",[\"fillvalue\"],[],b,[Sk.builtin.none.none$]);const c=[];for(let e=0;e<a.length;e++)c.push(Sk.abstr.iter(a[e]));if(this===d.zip_longest.prototype)return new d.zip_longest(c,b);a=new this.constructor;d.zip_longest.call(a,c,b);return a}}});d.__doc__=new Sk.builtin.str(\"An implementation of the python itertools module in Skulpt\");d.__package__=new Sk.builtin.str(\"\");return d};\n",
  "src/lib/keyword.js": "'use strict';function $builtinmodule(){const {ffi:{remapToPy:a},builtin:{frozenset:c,str:b}}=Sk,f=new b(\"keyword\"),g=a([\"iskeyword\",\"issoftkeyword\",\"kwlist\",\"softkwlist\"]),d=a(\"False None True and as assert async await break class continue def del elif else except finally for from global if import in is lambda nonlocal not or pass raise return try while with yield\".split(\" \")),e=a([\"_\",\"case\",\"match\"]),h=(new c(d)).tp$getattr(b.$contains),k=(new c(e)).tp$getattr(b.$contains);return{__name__:f,__all__:g,\nkwlist:d,softkwlist:e,iskeyword:h,issoftkeyword:k}};\n",
  "src/lib/math.js": "'use strict';const $builtinmodule=function(m){function u(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));var b=Sk.builtin.asnum$(a);a=Math.floor(b);if(a!=b)throw new Sk.builtin.ValueError(\"factorial() only accepts integral values\");if(0>a)throw new Sk.builtin.ValueError(\"factorial() not defined for negative numbers\");b=1;for(var c=2;c<=a&&18>=c;c++)b*=c;if(!(18>=a))for(b=JSBI.BigInt(b),c=19;c<=a;c++)b=JSBI.multiply(b,JSBI.BigInt(c));return new Sk.builtin.int_(b)}function n(a,b){function c(e,\nf){return 0==f?e:c(f,e%f)}function d(e,f){return JSBI.equal(f,JSBI.__ZERO)?e:d(f,JSBI.remainder(e,f))}\"number\"===typeof a&&\"number\"===typeof b?(a=Math.abs(a),b=Math.abs(b),a=c(a,b),a=0>a?-a:a):(a=JSBI.BigInt(a),b=JSBI.BigInt(b),a=d(a,b),JSBI.lessThan(a,JSBI.__ZERO)&&(a=JSBI.multiply(a,JSBI.BigInt(-1))));return a}const {builtin:{str:p,int_:v,float_:q,TypeError:y,pyCheckType:w,checkNumber:x},abstr:{lookupSpecial:r},misceval:{callsimOrSuspendArray:t}}=Sk;m={pi:new Sk.builtin.float_(Math.PI),e:new Sk.builtin.float_(Math.E),\ntau:new Sk.builtin.float_(2*Math.PI),nan:new Sk.builtin.float_(NaN),inf:new Sk.builtin.float_(Infinity)};const z=new p(\"__ceil__\"),k=function(a){return a?0>a?-1:1:0>1/a?-1:1},A=new p(\"__floor__\");Sk.abstr.setUpModuleMethods(\"math\",m,{acos:{$meth:function(a){Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a));return new Sk.builtin.float_(Math.acos(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the arc cosine (measured in radians) of x.\"},acosh:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\n\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);return new Sk.builtin.float_(Math.log(a+Math.sqrt(a*a-1)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the inverse hyperbolic cosine of x.\"},asin:{$meth:function(a){Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a));return new Sk.builtin.float_(Math.asin(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the arc sine (measured in radians) of x.\"},asinh:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\n\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);return new Sk.builtin.float_(Math.log(a+Math.sqrt(a*a+1)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the inverse hyperbolic sine of x.\"},atan:{$meth:function(a){Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a));return new Sk.builtin.float_(Math.atan(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the arc tangent (measured in radians) of x.\"},atan2:{$meth:function(a,b){Sk.builtin.pyCheckType(\"y\",\n\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(b));return new Sk.builtin.float_(Math.atan2(Sk.builtin.asnum$(a),Sk.builtin.asnum$(b)))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, y, x, /)\",$doc:\"Return the arc tangent (measured in radians) of y/x.\\n\\nUnlike atan(y/x), the signs of both x and y are considered.\"},atanh:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);return new Sk.builtin.float_(Math.log((1+\na)/(1-a))/2)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the inverse hyperbolic tangent of x.\"},ceil:{$meth:function(a){if(a.ob$type!==q){const b=r(a,z);if(void 0!==b)return t(b);w(\"\",\"real number\",x(a));a=Sk.builtin.asnum$(a)}else a=a.v;return new v(Math.ceil(a))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the ceiling of x as an Integral.\\n\\nThis is the smallest integer >= x.\"},comb:{$meth:function(a,b){var c=Sk.misceval.asIndexOrThrow(a);let d=Sk.misceval.asIndexOrThrow(b);\nif(0>c)throw new Sk.builtin.ValueError(\"n must be an non-negative integer\");if(0>d)throw new Sk.builtin.ValueError(\"k must be a non-negative integer\");if(d>a)return new Sk.builtin.int_(0);a=new Sk.builtin.int_(c);b=new Sk.builtin.int_(d);b=Sk.ffi.remapToJs(a.nb$subtract(b));b<d&&(d=b);if(0===d)return new Sk.builtin.int_(1);if(d>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError(\"min(n - k, k) must not exceed \"+Number.MAX_SAFE_INTEGER);c=new Sk.builtin.int_(1);let e=a;for(let f=1;f<d;f++)a=\na.nb$subtract(c),b=new Sk.builtin.int_(f+1),e=e.nb$multiply(a),e=e.nb$floor_divide(b);return e},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, n, k=None, /)\",$doc:\"Number of ways to choose k items from n items without repetition and with order.\\n\\nEvaluates to n! / (n - k)! when k <= n and evaluates\\nto zero when k > n.\\n\\nIf k is not specified or is None, then k defaults to n\\nand the function returns n!.\\n\\nRaises TypeError if either of the arguments are not integers.\\nRaises ValueError if either of the arguments are negative.\"},\ncopysign:{$meth:function(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b));b=Sk.builtin.asnum$(b);a=Sk.builtin.asnum$(a);const c=k(a);b=k(b);return new Sk.builtin.float_(a*c*b)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return a float with the magnitude (absolute value) of x but the sign of y.\\n\\nOn platforms that support signed zeros, copysign(1.0, -0.0)\\nreturns -1.0.\\n\"},cos:{$meth:function(a){Sk.builtin.pyCheckType(\"rad\",\n\"number\",Sk.builtin.checkNumber(a));return new Sk.builtin.float_(Math.cos(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the cosine of x (measured in radians).\"},cosh:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);a=Math.pow(Math.E,a);return new Sk.builtin.float_((a+1/a)/2)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the hyperbolic cosine of x.\"},degrees:{$meth:function(a){Sk.builtin.pyCheckType(\"rad\",\n\"number\",Sk.builtin.checkNumber(a));a=180/Math.PI*Sk.builtin.asnum$(a);return new Sk.builtin.float_(a)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Convert angle x from radians to degrees.\"},erf:{$meth:function(a){throw new Sk.builtin.NotImplementedError(\"math.erf() is not yet implemented in Skulpt\");},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Error function at x.\"},erfc:{$meth:function(a){throw new Sk.builtin.NotImplementedError(\"math.erfc() is not yet implemented in Skulpt\");},\n$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Complementary error function at x.\"},exp:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));let b=a.v;\"number\"!==typeof b&&(b=a.nb$float().v);if(Infinity==b||-Infinity==b||isNaN(b))return new Sk.builtin.float_(Math.exp(b));a=Math.exp(b);if(!isFinite(a))throw new Sk.builtin.OverflowError(\"math range error\");return new Sk.builtin.float_(a)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return e raised to the power of x.\"},\nexpm1:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);if(.7>Math.abs(a)){const b=Math.exp(a);return 1==b?new Sk.builtin.float_(a):new Sk.builtin.float_((b-1)*a/Math.log(b))}return new Sk.builtin.float_(Math.exp(a)-1)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return exp(x)-1.\\n\\nThis function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x.\"},fabs:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\n\"number\",Sk.builtin.checkNumber(a));let b=a.v;JSBI.__isBigInt(b)&&(b=a.nb$float().v);b=Math.abs(b);return new Sk.builtin.float_(b)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the absolute value of the float x.\"},factorial:{$meth:u,$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Find x!.\\n\\nRaise a ValueError if x is negative or non-integral.\"},floor:{$meth:function(a){if(a.ob$type===q)a=a.v;else{const b=r(a,A);if(void 0!==b)return t(b);w(\"x\",\"number\",x(a));a=Sk.builtin.asnum$(a)}return new v(Math.floor(a))},\n$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the floor of x as an Integral.\\n\\nThis is the largest integer <= x.\"},fmod:{$meth:function(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b));let c=a.v,d=b.v;\"number\"!==typeof c&&(c=a.nb$float().v);\"number\"!==typeof d&&(d=b.nb$float().v);if((Infinity==d||-Infinity==d)&&isFinite(c))return new Sk.builtin.float_(c);a=c%d;if(isNaN(a)&&!isNaN(c)&&!isNaN(d))throw new Sk.builtin.ValueError(\"math domain error\");\nreturn new Sk.builtin.float_(a)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return fmod(x, y), according to platform C.\\n\\nx % y may differ.\"},frexp:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);const b=[a,0];if(0!==a&&Number.isFinite(a)){var c=Math.abs(a);let d=Math.max(-1023,Math.floor(Math.log2(c))+1);for(c*=Math.pow(2,-d);.5>c;)c*=2,d--;for(;1<=c;)c*=.5,d++;0>a&&(c=-c);b[0]=c;b[1]=d}b[0]=new Sk.builtin.float_(b[0]);\nb[1]=new Sk.builtin.int_(b[1]);return new Sk.builtin.tuple(b)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the mantissa and exponent of x, as pair (m, e).\\n\\nm is a float and e is an int, such that x = m * 2.**e.\\nIf x is 0, m and e are both 0.  Else 0.5 <= abs(m) < 1.0.\"},fsum:{$meth:function(a){if(!Sk.builtin.checkIterable(a))throw new Sk.builtin.TypeError(\"'\"+Sk.abstr.typeName(a)+\"' object is not iterable\");let b=[];a=Sk.abstr.iter(a);let c;var d;for(d=a.tp$iternext();void 0!==d;d=\na.tp$iternext()){Sk.builtin.pyCheckType(\"\",\"real number\",Sk.builtin.checkNumber(d));c=0;var e=d.v;\"number\"!==typeof e&&(e=d.nb$float().v);d=e;for(let f=0,g=b.length;f<g;f++){let h=b[f];Math.abs(d)<Math.abs(h)&&(e=d,d=h,h=e);e=d+h;if(d=h-(e-d))b[c]=d,c++;d=e}b=b.slice(0,c).concat([d])}a=b.reduce(function(f,g){return f+g},0);return new Sk.builtin.float_(a)},$flags:{OneArg:!0},$textsig:\"($module, seq, /)\",$doc:\"Return an accurate floating point sum of values in the iterable seq.\\n\\nAssumes IEEE-754 floating point arithmetic.\"},\ngamma:{$meth:function(a){throw new Sk.builtin.NotImplementedError(\"math.gamma() is not yet implemented in Skulpt\");},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Gamma function at x.\"},gcd:{$meth:function(a,b){Sk.builtin.pyCheckType(\"a\",\"integer\",Sk.builtin.checkInt(a));Sk.builtin.pyCheckType(\"b\",\"integer\",Sk.builtin.checkInt(b));a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);b=n(a,b);return\"number\"===typeof b?new Sk.builtin.int_(b):new Sk.builtin.int_(b.toString())},$flags:{MinArgs:2,MaxArgs:2},\n$textsig:\"($module, x, y, /)\",$doc:\"greatest common divisor of x and y\"},hypot:{$meth:function(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b));a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);return new Sk.builtin.float_(Math.sqrt(a*a+b*b))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return the Euclidean distance, sqrt(x*x + y*y).\"},isclose:{$meth:function(a,b){Sk.abstr.checkArgsLen(\"isclose\",a,2,\n2);var c=Sk.abstr.copyKeywordsToNamedArgs(\"isclose\",[\"rel_tol\",\"abs_tol\"],[],b,[new Sk.builtin.float_(1E-9),new Sk.builtin.float_(0)]);b=a[0];var d=a[1];a=c[0];c=c[1];Sk.builtin.pyCheckType(\"a\",\"number\",Sk.builtin.checkNumber(b));Sk.builtin.pyCheckType(\"b\",\"number\",Sk.builtin.checkNumber(d));Sk.builtin.pyCheckType(\"rel_tol\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"abs_tol\",\"number\",Sk.builtin.checkNumber(c));b=Sk.builtin.asnum$(b);d=Sk.builtin.asnum$(d);a=Sk.builtin.asnum$(a);c=\nSk.builtin.asnum$(c);if(0>a||0>c)throw new Sk.builtin.ValueError(\"tolerances must be non-negative\");if(b==d)return Sk.builtin.bool.true$;if(Infinity==b||-Infinity==b||Infinity==d||-Infinity==d)return Sk.builtin.bool.false$;const e=Math.abs(d-b);return new Sk.builtin.bool(e<=Math.abs(a*d)||e<=Math.abs(a*b)||e<=c)},$flags:{FastCall:!0},$textsig:\"($module, /, a, b, *, rel_tol=1e-09, abs_tol=0.0)\",$doc:'Determine whether two floating point numbers are close in value.\\n\\n  rel_tol\\n    maximum difference for being considered \"close\", relative to the\\n    magnitude of the input values\\n  abs_tol\\n    maximum difference for being considered \"close\", regardless of the\\n    magnitude of the input values\\n\\nReturn True if a is close in value to b, and False otherwise.\\n\\nFor the values to be considered close, the difference between them\\nmust be smaller than at least one of the tolerances.\\n\\n-inf, inf and NaN behave similarly to the IEEE 754 Standard.  That\\nis, NaN is not close to anything, even itself.  inf and -inf are\\nonly close to themselves.'},\nisfinite:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));const b=Sk.builtin.asnum$(a);return Sk.builtin.checkInt(a)?Sk.builtin.bool.true$:isFinite(b)?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return True if x is neither an infinity nor a NaN, and False otherwise.\"},isinf:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));const b=Sk.builtin.asnum$(a);return Sk.builtin.checkInt(a)?\nSk.builtin.bool.false$:isFinite(b)||isNaN(b)?Sk.builtin.bool.false$:Sk.builtin.bool.true$},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return True if x is a positive or negative infinity, and False otherwise.\"},isnan:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);return isNaN(a)?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return True if x is a NaN (not a number), and False otherwise.\"},\nisqrt:{$meth:function(a){a=Sk.misceval.asIndexOrThrow(a);if(0>a)throw new Sk.builtin.ValueError(\"isqrt() argument must be nonnegative\");if(0==a)return new Sk.builtin.int_(0);if(\"number\"===typeof a)return new Sk.builtin.int_(Math.floor(Math.sqrt(a)));{var b=a.toString(2).length;b=Math.floor((b-1)/2);var c=b.toString(2).length;const g=JSBI.BigInt(1);var d=JSBI.BigInt(2);b=JSBI.BigInt(b);d=JSBI.multiply(d,b);let h=g,l=JSBI.BigInt(0);for(;0<c;){c--;var e=l;l=JSBI.signedRightShift(b,JSBI.BigInt(c));var f=\nJSBI.subtract(JSBI.subtract(l,e),g);f=JSBI.leftShift(h,f);e=JSBI.add(JSBI.subtract(JSBI.subtract(d,e),l),g);e=JSBI.signedRightShift(a,e);h=JSBI.add(f,JSBI.divide(e,h))}c=h;JSBI.greaterThan(JSBI.multiply(c,c),a)&&(c=JSBI.subtract(c,g));JSBI.lessThanOrEqual(c,JSBI.BigInt(Number.MAX_SAFE_INTEGER))&&(c=Number(c));a=new Sk.builtin.int_(c)}return a},$flags:{OneArg:!0},$textsig:\"($module, n, /)\",$doc:\"Return the integer part of the square root of the input.\"},lcm:{$meth:function(...a){function b(g){return\"number\"===\ntypeof g?new Sk.builtin.int_(Math.abs(g)):JSBI.lessThan(g,JSBI.__ZERO)?new Sk.builtin.int_(JSBI.unaryMinus(g)):new Sk.builtin.int_(g)}const c=a.length;if(0===c)return new Sk.builtin.int_(1);let d;for(d=0;d<c;++d)a[d]=Sk.misceval.asIndexOrThrow(a[d]);let e=a[0];if(1===c)return b(e);let f;for(d=1;d<c;++d){f=a[d];if(0===f)return new Sk.builtin.int_(0);if(\"number\"===typeof e&&\"number\"===typeof f){let g=e/n(e,f)*f;g=Math.abs(g);e=g>Number.MAX_SAFE_INTEGER?JSBI.BigInt(e):g}else e=JSBI.BigInt(e);\"number\"!==\ntypeof e&&(f=JSBI.BigInt(f),e=JSBI.multiply(JSBI.divide(e,n(e,f)),f))}return b(e)},$flags:{MinArgs:0},$textsig:\"($module, *integers, /)\",$doc:\"Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1.\"},ldexp:{$meth:function(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));\nSk.builtin.pyCheckType(\"i\",\"integer\",Sk.builtin.checkInt(b));var c=a.v;\"number\"!==typeof c&&(c=a.nb$float().v);a=Sk.builtin.asnum$(b);if(Infinity==c||-Infinity==c||0==c||isNaN(c))return new Sk.builtin.float_(c);c*=Math.pow(2,a);if(!isFinite(c))throw new Sk.builtin.OverflowError(\"math range error\");return new Sk.builtin.float_(c)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, i, /)\",$doc:\"Return x * (2**i).\\n\\nThis is essentially the inverse of frexp().\"},lgamma:{$meth:function(a){throw new Sk.builtin.NotImplementedError(\"math.lgamma() is not yet implemented in Skulpt\");\n},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Natural logarithm of absolute value of Gamma function at x.\"},log:{$meth:function(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));var c=Sk.builtin.asnum$(a);if(0>=c)throw new Sk.builtin.ValueError(\"math domain error\");void 0===b?b=Math.E:(Sk.builtin.pyCheckType(\"base\",\"number\",Sk.builtin.checkNumber(b)),b=Sk.builtin.asnum$(b));if(0>=b)throw new Sk.builtin.ValueError(\"math domain error\");Sk.builtin.checkFloat(a)||c<Number.MAX_SAFE_INTEGER?\nc=Math.log(c)/Math.log(b):(c=(new Sk.builtin.str(a)).$jsstr(),a=c.length,c=parseFloat(\"0.\"+c),c=(a*Math.log(10)+Math.log(c))/Math.log(b));return new Sk.builtin.float_(c)},$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:\"log(x, [base=e])\\nReturn the logarithm of x to the given base.\\n\\nIf the base not specified, returns the natural logarithm (base e) of x.\"},log10:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));var b=Sk.builtin.asnum$(a);if(0>=b)throw new Sk.builtin.ValueError(\"math domain error\");\nSk.builtin.checkFloat(a)||b<Number.MAX_SAFE_INTEGER?b=Math.log10(b):(b=(new Sk.builtin.str(a)).$jsstr(),a=b.length,b=parseFloat(\"0.\"+b),b=a+Math.log10(b));return new Sk.builtin.float_(b)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the base 10 logarithm of x.\"},log1p:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));let b=a.v;\"number\"!==typeof b&&(b=a.nb$float().v);if(-1>=b)throw new Sk.builtin.ValueError(\"math domain error\");return 0==b||Math.abs(b)<\nNumber.EPSILON/2?new Sk.builtin.float_(b):-.5<=b&&1>=b?(a=1+b,new Sk.builtin.float_(Math.log(a)-(a-1-b)/a)):new Sk.builtin.float_(Math.log(1+b))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the natural logarithm of 1+x (base e).\\n\\nThe result is computed in a way which is accurate for x near zero.\"},log2:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));var b=Sk.builtin.asnum$(a);if(0>=b)throw new Sk.builtin.ValueError(\"math domain error\");Sk.builtin.checkFloat(a)||\nb<Number.MAX_SAFE_INTEGER?b=Math.log2(b):(b=(new Sk.builtin.str(a)).$jsstr(),a=b.length,b=parseFloat(\"0.\"+b),b=a*Math.log2(10)+Math.log2(b));return new Sk.builtin.float_(b)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the base 2 logarithm of x.\"},modf:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);if(!isFinite(a)){if(Infinity==a)return new Sk.builtin.tuple([new Sk.builtin.float_(0),new Sk.builtin.float_(a)]);if(-Infinity==a)return new Sk.builtin.tuple([new Sk.builtin.float_(-0),\nnew Sk.builtin.float_(a)]);if(isNaN(a))return new Sk.builtin.tuple([new Sk.builtin.float_(a),new Sk.builtin.float_(a)])}const b=k(a);a=Math.abs(a);const c=b*Math.floor(a);return new Sk.builtin.tuple([new Sk.builtin.float_(b*(a-Math.floor(a))),new Sk.builtin.float_(c)])},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the fractional and integer parts of x.\\n\\nBoth results carry the sign of x and are floats.\"},perm:{$meth:function(a,b){if(void 0===b||Sk.builtin.checkNone(b))return u(a);a=\nSk.misceval.asIndexOrThrow(a);b=Sk.misceval.asIndexOrThrow(b);if(0>a)throw new Sk.builtin.ValueError(\"n must be an non-negative integer\");if(0>b)throw new Sk.builtin.ValueError(\"k must be a non-negative integer\");if(b>a)return new Sk.builtin.int_(0);if(0===b)return new Sk.builtin.int_(1);if(b>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError(\"k must not exceed \"+Number.MAX_SAFE_INTEGER);const c=new Sk.builtin.int_(1);let d=a=new Sk.builtin.int_(a);for(let e=1;e<b;e++)a=a.nb$subtract(c),d=\nd.nb$multiply(a);return d},$flags:{MinArgs:1,MaxArgs:2},$textsig:\"($module, n, k=None, /)\",$doc:\"'Number of ways to choose k items from n items without repetition and with order.\\n\\nEvaluates to n! / (n - k)! when k <= n and evaluates\\nto zero when k > n.\\n\\nIf k is not specified or is None, then k defaults to n\\nand the function returns n!.\\n\\nRaises TypeError if either of the arguments are not integers.\\nRaises ValueError if either of the arguments are negative.'\"},prod:{$meth:function(a,b){function c(){return Sk.misceval.iterFor(f,\nh=>{if(h.constructor===Sk.builtin.int_)g=g.nb$multiply(h);else{if(h.constructor===Sk.builtin.float_)return g=g.nb$float().nb$multiply(h),new Sk.misceval.Break(\"float\");g=Sk.abstr.numberBinOp(g,h,\"Mult\");return new Sk.misceval.Break(\"slow\")}})}function d(){return Sk.misceval.iterFor(f,h=>{if(h.constructor===Sk.builtin.float_||h.constructor===Sk.builtin.int_)g=g.nb$multiply(h);else return g=Sk.abstr.numberBinOp(g,h,\"Mult\"),new Sk.misceval.Break(\"slow\")})}function e(){return Sk.misceval.iterFor(f,h=>\n{g=Sk.abstr.numberBinOp(g,h,\"Mult\")})}Sk.abstr.checkArgsLen(\"prod\",a,1,1);a=Sk.abstr.copyKeywordsToNamedArgs(\"prod\",[null,\"start\"],a,b,[new Sk.builtin.int_(1)]);const f=Sk.abstr.iter(a[0]);let g=a[1];a=g.constructor===Sk.builtin.int_?c():g.constructor===Sk.builtin.float_?\"float\":\"slow\";return Sk.misceval.chain(a,h=>\"float\"===h?d():h,h=>{if(\"slow\"===h)return e()},()=>g)},$flags:{FastCall:!0},$textsig:\"($module, iterable, /, *, start=1)\",$doc:\"Calculate the product of all the elements in the input iterable. The default start value for the product is 1.\\n\\nWhen the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types.\"},\npow:{$meth:function(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b));let c=a.v,d=b.v;\"number\"!==typeof c&&(c=a.nb$float().v);\"number\"!==typeof d&&(d=b.nb$float().v);if(0==c&&0>d)throw new Sk.builtin.ValueError(\"math domain error\");if(1==c)return new Sk.builtin.float_(1);if(Number.isFinite(c)&&Number.isFinite(d)&&0>c&&!Number.isInteger(d))throw new Sk.builtin.ValueError(\"math domain error\");if(-1==c&&(-Infinity==d||Infinity==\nd))return new Sk.builtin.float_(1);a=Math.pow(c,d);if(Number.isFinite(c)&&Number.isFinite(d)&&(Infinity==a||-Infinity==a))throw new Sk.builtin.OverflowError(\"math range error\");return new Sk.builtin.float_(a)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return x**y (x to the power of y).\"},radians:{$meth:function(a){Sk.builtin.pyCheckType(\"deg\",\"number\",Sk.builtin.checkNumber(a));a=Math.PI/180*Sk.builtin.asnum$(a);return new Sk.builtin.float_(a)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",\n$doc:\"Convert angle x from degrees to radians.\"},remainder:{$meth:function(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b));let c=a.v;var d=b.v;\"number\"!==typeof c&&(c=a.nb$float().v);\"number\"!==typeof d&&(d=b.nb$float().v);if(isFinite(c)&&isFinite(d)){let e;if(0==d)throw new Sk.builtin.ValueError(\"math domain error\");a=Math.abs(c);d=Math.abs(d);e=a%d;b=d-e;if(e<b)a=e;else if(e>b)a=-b;else{if(e!=b)throw new Sk.builtin.AssertionError;\na=e-.5*(a-e)%d*2}return new Sk.builtin.float_(k(c)*a)}if(isNaN(c))return a;if(isNaN(d))return b;if(Infinity==c||-Infinity==c)throw new Sk.builtin.ValueError(\"math domain error\");if(Infinity!=d&&-Infinity!=d)throw new Sk.builtin.AssertionError;return new Sk.builtin.float_(c)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Difference between x and the closest integer multiple of y.\\n\\nReturn x - n*y where n*y is the closest integer multiple of y.\\nIn the case where x is exactly halfway between two multiples of\\ny, the nearest even value of n is used. The result is always exact.\"},\nsin:{$meth:function(a){Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a));return new Sk.builtin.float_(Math.sin(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the sine of x (measured in radians).\"},sinh:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);a=Math.pow(Math.E,a);return new Sk.builtin.float_((a-1/a)/2)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the hyperbolic sine of x.\"},\nsqrt:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);if(0>a)throw new Sk.builtin.ValueError(\"math domain error\");return new Sk.builtin.float_(Math.sqrt(a))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the square root of x.\"},tan:{$meth:function(a){Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a));return new Sk.builtin.float_(Math.tan(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the tangent of x (measured in radians).\"},\ntanh:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);if(0===a)return new Sk.builtin.float_(a);a=Math.pow(Math.E,a);const b=1/a;return new Sk.builtin.float_((a-b)/2/((a+b)/2))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the hyperbolic tangent of x.\"},trunc:{$meth:function(a){if(a.ob$type===q)return a.nb$int();const b=r(a,p.$trunc);if(void 0===b)throw new y(`type ${a.tp$name} doesn't define __trunc__ method`);return t(b)},$flags:{OneArg:!0},\n$textsig:\"($module, x, /)\",$doc:\"Truncates the Real x to the nearest Integral toward 0.\\n\\nUses the __trunc__ magic method.\"}});return m};\n",
  "src/lib/operator.js": "'use strict';function $builtinmodule(v){function c(a,b){return{$meth:a,$doc:b,...K[a.length]}}function d(a){return\"Same as \"+a+\".\"}const {builtin:{str:m,tuple:D,list:L,int_:E,bool:l,TypeError:p,ValueError:M,none:{none$:F},NotImplemented:{NotImplemented$:N},abs:O,len:P,checkString:G,checkInt:H},abstr:{buildNativeClass:w,checkNoKwargs:I,checkArgsLen:x,checkOneArg:y,numberUnaryOp:r,numberBinOp:h,numberInplaceBinOp:k,objectGetItem:z,objectDelItem:Q,objectSetItem:R,sequenceConcat:S,sequenceContains:T,\nsequenceGetCountOf:U,sequenceGetIndexOf:V,sequenceInPlaceConcat:W,typeName:J,lookupSpecial:X,gattr:A,setUpModuleMethods:Y},misceval:{richCompareBool:n,asIndexOrThrow:Z,chain:u,callsimArray:aa,callsimOrSuspendArray:ba,objectRepr:t},generic:{getAttr:B}}=Sk;v=\"abs add and_ concat contains delitem eq floordiv ge getitem gt iadd iand iconcat ifloordiv ilshift imatmul imod imul index inv invert ior ipow irshift isub itruediv ixor le lshift lt matmul mod mul ne neg not_ or_ pos pow rshift setitem sub truediv xor\".split(\" \");\nconst ca=[\"attrgetter\",\"countOf\",\"indexOf\",\"is_\",\"is_not\",\"itemgetter\",\"length_hint\",\"methodcaller\",\"truth\",...v].sort(),g={__name__:new m(\"operator\"),__doc__:new m(\"Operator interface.\\n\\nThis module exports a set of functions implemented in javascript corresponding\\nto the intrinsic operators of Python.  For example, operator.add(x, y)\\nis equivalent to the expression x+y.  The function names are those\\nused for special methods; variants without leading and trailing\\n'__' are also provided for convenience.\"),\n__all__:new L(ca.map(a=>new m(a)))};g.itemgetter=w(\"operator.itemgetter\",{constructor:function(a){this.items=a;this.oneitem=1===a.length;this.item=a[0];this.in$repr=!1},slots:{tp$getattr:B,tp$new(a,b){I(\"itemgetter\",b);x(\"itemgetter\",a,1);return new g.itemgetter(a)},tp$call(a,b){y(\"itemgetter\",a,b);const e=a[0];return this.oneitem?z(e,this.item,!0):new D(this.items.map(f=>z(e,f)))},tp$doc:\"Return a callable object that fetches the given item(s) from its operand.\\n            After f = itemgetter(2), the call f(r) returns r[2].\\n            After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])\",\n$r(){if(this.in$repr)return new m(this.tp$name+\"(...)\");this.in$repr=!0;const a=this.tp$name+\"(\"+this.items.map(b=>t(b)).join(\", \")+\")\";this.in$repr=!1;return a}}});g.attrgetter=w(\"operator.attrgetter\",{constructor:function(a){this.attrs=a;this.oneattr=1===a.length;this.attr=a[0];this.in$repr=!1},slots:{tp$getattr:B,tp$new(a,b){I(\"attrgetter\",b);x(\"attrgetter\",a,1);b=[];for(let e=0;e<a.length;e++){const f=a[e];if(!G(f))throw new p(\"attribute name must be a string\");const q=f.toString();q.includes(\".\")?\nb.push(q.split(\".\").map(C=>new m(C))):b.push([f])}return new g.attrgetter(b)},tp$call(a,b){y(\"attrgetter\",a,b);const e=a[0];if(this.oneattr)return this.attr.reduce((f,q)=>A(f,q),e);a=this.attrs.map(f=>f.reduce((q,C)=>A(q,C),e));return new D(a)},tp$doc:\"attrgetter(attr, ...) --\\x3e attrgetter object\\n\\nReturn a callable object that fetches the given attribute(s) from its operand.\\nAfter f = attrgetter('name'), the call f(r) returns r.name.\\nAfter g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\\nAfter h = attrgetter('name.first', 'name.last'), the call h(r) returns\\n(r.name.first, r.name.last).\",\n$r(){if(this.in$repr)return new m(this.tp$name+\"(...)\");this.in$repr=!0;const a=this.tp$name+\"(\"+this.items.map(b=>t(b)).join(\", \")+\")\";this.in$repr=!1;return a}}});g.methodcaller=w(\"operator.methodcaller\",{constructor:function(a,b,e){this.$name=a;this.args=b;this.kwargs=e||[];this.in$repr=!1},slots:{tp$getattr:B,tp$new(a,b){x(\"methodcaller\",a,1);const e=a[0];if(!G(e))throw new p(\"method name must be a string\");return new g.methodcaller(e,a.slice(1),b)},tp$call(a,b){y(\"methodcaller\",a,b);return u(A(a[0],\nthis.$name,!0),e=>ba(e,this.args,this.kwargs))},tp$doc:\"methodcaller(name, ...) --\\x3e methodcaller object\\n\\nReturn a callable object that calls the given method on its operand.\\nAfter f = methodcaller('name'), the call f(r) returns r.name().\\nAfter g = methodcaller('name', 'date', foo=1), the call g(r) returns\\nr.name('date', foo=1).\",$r(){if(this.in$repr)return new m(this.tp$name+\"(...)\");this.in$repr=!0;let a=[t(this.$name)];a.push(...this.args.map(b=>t(b)));for(let b=0;b<this.kwargs.length;b+=\n2)a.push(this.kwargs[b]+\"=\"+t(this.kwargs[b+1]));a=this.tp$name+\"(\"+a.join(\", \")+\")\";this.in$repr=!1;return a}}});const K={1:{$flags:{OneArg:!0},$textsig:\"($module, a, /)\"},2:{$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\"},3:{$flags:{MinArgs:3,MaxArgs:3},$textsig:\"($module, a, b, c, /)\"}};Y(\"operator\",g,{lt:c((a,b)=>l(n(a,b,\"Lt\")),d(\"a < b\")),le:c((a,b)=>l(n(a,b,\"LtE\")),d(\"a <= b\")),eq:c((a,b)=>l(n(a,b,\"Eq\")),d(\"a == b\")),ne:c((a,b)=>l(n(a,b,\"NotEq\")),d(\"a != b\")),ge:c((a,b)=>l(n(a,b,\n\"GtE\")),d(\"a >= b\")),gt:c((a,b)=>l(n(a,b,\"Gt\")),d(\"a > b\")),not_:c(a=>r(a,\"Not\"),d(\"not a\")),truth:c(a=>l(a),\"Return True if a is true, False otherwise.\"),is_:c((a,b)=>l(n(a,b,\"Is\")),d(\"a is b\")),is_not:c((a,b)=>l(n(a,b,\"IsNot\")),d(\"a is not b\")),abs:c(a=>O(a),d(\"abs(a)\")),add:c((a,b)=>h(a,b,\"Add\"),d(\"a + b\")),and_:c((a,b)=>h(a,b,\"BitAnd\"),d(\"a & b\")),floordiv:c((a,b)=>h(a,b,\"FloorDiv\"),d(\"a // b\")),index:c(a=>new E(Z(a)),d(\"a.__index__()\")),inv:c(a=>r(a,\"Invert\"),d(\"~a\")),invert:c(a=>r(a,\"Invert\"),\nd(\"~a\")),lshift:c((a,b)=>h(a,b,\"LShift\"),d(\"a << b\")),mod:c((a,b)=>h(a,b,\"Mod\"),d(\"a % b\")),mul:c((a,b)=>h(a,b,\"Mult\"),d(\"a * b\")),matmul:c((a,b)=>h(a,b,\"MatMult\"),d(\"a @ b\")),neg:c(a=>r(a,\"USub\"),d(\"-a\")),or_:c((a,b)=>h(a,b,\"BitOr\"),d(\"a | b\")),pos:c(a=>r(a,\"UAdd\"),d(\"+a\")),pow:c((a,b)=>h(a,b,\"Pow\"),d(\"a ** b\")),rshift:c((a,b)=>h(a,b,\"RShift\"),d(\"a >> b\")),sub:c((a,b)=>h(a,b,\"Sub\"),d(\"a - b\")),truediv:c((a,b)=>h(a,b,\"Div\"),d(\"a / b\")),xor:c((a,b)=>h(a,b,\"BitXor\"),d(\"a ^ b\")),concat:c((a,b)=>S(a,\nb),d(\"a + b, for a and b sequences\")),contains:c((a,b)=>u(T(a,b),l),d(\"b in a (note reversed operands)\")),countOf:c((a,b)=>U(a,b),\"Return thenumber of times b occurs in a.\"),delitem:c((a,b)=>u(Q(a,b,!0),()=>F),d(\"del a[b]\")),getitem:c((a,b)=>z(a,b,!0),d(\"a[b]\")),indexOf:c((a,b)=>V(a,b),\"Return the first index of b in a\"),setitem:c((a,b,e)=>u(R(a,b,e,!0),()=>F),d(\"a[b] = c\")),length_hint:{$meth:function(a,b){if(void 0===b)b=new E(0);else if(!H(b))throw new p(\"'\"+J(b)+\"' object cannot be interpreted as an integer\");\ntry{return P(a)}catch(f){if(!(f instanceof p))throw f;}a=X(a,m.$length_hint);if(void 0===a)return b;let e;try{e=aa(a,[])}catch(f){if(!(f instanceof p))throw f;return b}if(e===N)return b;if(!H(e))throw new p(\"__length_hint__ must be an integer, not \"+J(e));if(e.nb$isnegative())throw new M(\"__length_hint__() should return >= 0\");return e},$flags:{MinArgs:1,MaxArgs:2},$textsig:\"($module, obj, default=0, /)\",$doc:\"Return an estimate of the number of items in obj.\\n\\nThis is useful for presizing containers when building from an iterable.\\n\\nIf the object supports len(), the result will be exact.\\nOtherwise, it may over- or under-estimate by an arbitrary amount.\\nThe result will be an integer >= 0.\"},\niadd:c((a,b)=>k(a,b,\"Add\"),d(\"a += b\")),iand:c((a,b)=>k(a,b,\"BitAnd\"),d(\"a &= b\")),iconcat:c((a,b)=>W(a,b),d(\"a += b, for a and b sequences\")),ifloordiv:c((a,b)=>k(a,b,\"FloorDiv\"),d(\"a //= b\")),ilshift:c((a,b)=>k(a,b,\"LShift\"),d(\"a <<= b\")),imod:c((a,b)=>k(a,b,\"Mod\"),d(\"a %= b\")),imul:c((a,b)=>k(a,b,\"Mult\"),d(\"a *= b\")),imatmul:c((a,b)=>k(a,b,\"MatMult\"),d(\"a @= b\")),ior:c((a,b)=>k(a,b,\"BitOr\"),d(\"a |= b\")),ipow:c((a,b)=>k(a,b,\"Pow\"),d(\"a **= b\")),irshift:c((a,b)=>k(a,b,\"RShift\"),d(\"a >>= b\")),isub:c((a,\nb)=>k(a,b,\"Sub\"),d(\"a -= b\")),itruediv:c((a,b)=>k(a,b,\"Div\"),d(\"a /= b\")),ixor:c((a,b)=>k(a,b,\"BitXor\"),d(\"a ^= b\"))});v.forEach(a=>{g[`__${a.replace(\"_\",\"\")}__`]=g[a]});g.div=g.truediv;g.__div__=g.div;return g};\n",
  "src/lib/random.py": "from _random import *\nfrom math import floor as _floor, isfinite as _isfinite\nfrom itertools import accumulate as _accumulate, repeat as _repeat\nfrom bisect import bisect as _bisect\n\ndef choices(population, weights=None, *, cum_weights=None, k=1):\n    '''Return a k sized list of population elements chosen with replacement.\n\n    If the relative weights or cumulative weights are not specified,\n    the selections are made with equal probability.\n\n    '''\n    n = len(population)\n    if cum_weights is None:\n        if weights is None:\n            floor = _floor\n            n += 0.0    # convert to float for a small speed improvement\n            return [population[floor(random() * n)] for i in _repeat(None, k)]\n        try:\n            cum_weights = list(_accumulate(weights))\n        except TypeError:\n            if not isinstance(weights, int):\n                raise\n            k = weights\n            raise TypeError(\n                'The number of choices must be a keyword argument: k=' + k\n            )\n    elif weights is not None:\n        raise TypeError('Cannot specify both weights and cumulative weights')\n    if len(cum_weights) != n:\n        raise ValueError('The number of weights does not match the population')\n    total = cum_weights[-1] + 0.0   # convert to float\n    if total <= 0.0:\n        raise ValueError('Total of weights must be greater than zero')\n    if not _isfinite(total):\n        raise ValueError('Total of weights must be finite')\n    bisect = _bisect\n    hi = n - 1\n    return [population[bisect(cum_weights, random() * total, 0, hi)]\n            for i in _repeat(None, k)]",
  "src/lib/re.js": "'use strict';function $builtinmodule(L){function D(a,b){return function(c){if(c instanceof d.RegexFlag||c instanceof l){var e=this.v;c=c.v;if(\"number\"===typeof e&&\"number\"===typeof c)return e=a(e,c),0>e&&(e+=4294967296),new d.RegexFlag(e);e=JSBI.BigUp(e);c=JSBI.BigUp(c);return new d.RegexFlag(JSBI.numberIfSafe(b(e,c)))}return M}}function V(a,b){a=a.toString();let c=\"g\",e=0;a=a.replace(W,(f,g)=>{for(let n of g)e|=X[n].valueOf();return\"\"});N.forEach(([f,g])=>{if((g.valueOf()&e)===g.valueOf())throw new d.error(\"bad bad inline flags: \"+\nf);});b=x(new d.RegexFlag(e),b,\"BitOr\");N.forEach(([f,g])=>{if(x(g,b,\"BitAnd\")===g)throw new E(f);});x(d.A,b,\"BitAnd\")!==d.A&&(b=x(d.U,b,\"BitOr\"));Object.entries(F).forEach(([f,g])=>{x(g,b,\"BitAnd\")===g&&(c+=f)});b=new d.RegexFlag(b.valueOf());return[a,c,b]}function Y(a,b){let c,e;[c,e,b]=V(a,b);var f=B[a.toString()];if(f&&f.$flags===b)return f;const g={};c=(\"_\"+c).replace(Z,\"$1$2\\\\]$3\");c=c.replace(aa,(m,r,p,G,O,P)=>{switch(p){case \"\\\\A\":return r+Q+\"^\";case \"\\\\Z\":return r+\"$(?!\\\\n)\";case \"{,\":return r+\n\"{0,\";case \"$\":return r+\"(?:(?=\\\\n$)|$)\";default:if(p.endsWith(\">\"))return g[O]=!0,r+\"(?<\"+O+\">\";if(!g[G])throw new d.error(\"unknown group name \"+G+\" at position \"+P+1,a,new l(P+1));return r+\"\\\\k<\"+G+\">\"}});c=c.slice(1);let n;f=c;e.includes(\"u\")&&(f=c.replace(ba,m=>{switch(m){case \"\\\\ \":return\" \";case \"\\\\\\t\":return\"\\\\t\";case \"\\\\\\n\":return\"\\\\n\";case \"\\\\\\v\":return\"\\\\v\";case \"\\\\\\f\":return\"\\\\f\";case \"\\\\r\":return\"\\\\r\";default:return m.slice(1)}}));try{n=new RegExp(f,e)}catch(m){if(ca.test(m.message))try{n=\nnew RegExp(c,e.replace(\"u\",\"\"))}catch(r){throw b=r.message.substring(r.message.lastIndexOf(\":\")+2)+\" in pattern: \"+a.toString(),new d.error(b,a);}else throw b=m.message.substring(m.message.lastIndexOf(\":\")+2)+\" in pattern: \"+a.toString(),new d.error(b,a);}b=new d.Pattern(n,a,b);return B[a.toString()]=b}function t(a,b){if(a instanceof d.Pattern){if(b!==h||b.valueOf())throw new E(\"cannot process flags argument with compiled pattern\");return a}if(!y(a))throw new v(\"first argument must be string or compiled pattern\");\nreturn Y(a,b)}const {builtin:{dict:H,str:k,list:I,int_:l,type:da,tuple:u,mappingproxy:ea,slice:fa,none:{none$:q},NotImplemented:{NotImplemented$:M},Exception:R,OverflowError:ha,IndexError:S,TypeError:v,ValueError:E,checkInt:ia,checkString:y,checkCallable:ja,hex:ka},abstr:{buildNativeClass:A,typeName:z,checkOneArg:la,numberBinOp:x,copyKeywordToNamedArgs:ma,setUpModuleMethods:na},misceval:{iterator:T,objectRepr:C,asIndexSized:J,isIndex:oa,callsimArray:pa}}=Sk,d={__name__:new k(\"re\"),__all__:new I(\"match fullmatch search sub subn split findall finditer compile purge template escape error Pattern Match A I L M S X U ASCII IGNORECASE LOCALE MULTILINE DOTALL VERBOSE UNICODE\".split(\" \").map(a=>\nnew k(a)))},U={};L=A(\"RegexFlagMeta\",{constructor:function(){},base:da,slots:{tp$iter(){const a=Object.values(K)[Symbol.iterator]();return new T(()=>a.next().value)},sq$contains(a){if(!(a instanceof this))throw new v(\"unsupported operand type(s) for 'in': '\"+z(a)+\"' and '\"+z(this)+\"'\");return Object.values(K).includes(a)}}});d.RegexFlag=A(\"RegexFlag\",{meta:L,base:l,constructor:function(a){const b=U[a];if(b)return b;this.v=a;U[a]=this},slots:{tp$new(a,b){la(\"RegexFlag\",a,b);a=a[0].valueOf();if(!ia(a))throw new E(C(a)+\n\" is not a valid RegexFlag\");return new d.RegexFlag(a)},$r(){let a=this.valueOf();const b=0>a;a=b?~a:a;const c=[];Object.entries(K).forEach(([f,g])=>{g=g.valueOf();a&g&&(a&=~g,c.push(\"re.\"+f))});a&&c.push(ka(a).toString());let e=c.join(\"|\");b&&(e=1<c.length?\"~(\"+e+\")\":\"~\"+e);return new k(e)},sq$contains(a){if(!(a instanceof d.RegexFlag))throw new v(\"'in' requires a RegexFlag not \"+z(a));return this.nb$and(a)===a},nb$and:D((a,b)=>a&b,JSBI.bitwiseAnd),nb$or:D((a,b)=>a|b,JSBI.bitwiseOr),nb$xor:D((a,\nb)=>a^b,JSBI.bitwiseXor),nb$invert:function(){const a=this.v;return\"number\"===typeof a?new d.RegexFlag(~a):new d.RegexFlag(JSBI.bitwiseNot(a))}},proto:{valueOf(){return this.v}},flags:{sk$unacceptableBase:!0}});d.TEMPLATE=d.T=new d.RegexFlag(1);d.IGNORECASE=d.I=new d.RegexFlag(2);d.LOCALE=d.L=new d.RegexFlag(4);d.MULTILINE=d.M=new d.RegexFlag(8);d.DOTALL=d.S=new d.RegexFlag(16);d.UNICODE=d.U=new d.RegexFlag(32);d.VERBOSE=d.X=new d.RegexFlag(64);d.DEBUG=new d.RegexFlag(128);d.ASCII=d.A=new d.RegexFlag(256);\nconst K={ASCII:d.A,IGNORECASE:d.I,LOCALE:d.L,UNICODE:d.U,MULTILINE:d.M,DOTALL:d.S,VERBOSE:d.X,TEMPLATE:d.T,DEBUG:d.DEBUG},F={i:d.I,m:d.M,s:d.S,u:d.U},X={i:d.I,a:d.A,s:d.S,L:d.L,m:d.M,u:d.U,x:d.X};RegExp.prototype.hasOwnProperty(\"sticky\")||delete F.s;RegExp.prototype.hasOwnProperty(\"unicode\")||delete F.u;const N=Object.entries({\"cannot use LOCALE flag with a str pattern\":d.L,\"ASCII and UNICODE flags are incompatible\":new d.RegexFlag(d.A.valueOf()|d.U.valueOf())}),W=/\\(\\?([isamux]+)\\)/g;let Q=\"(?<!\\\\\\\\n)\";\n(function(){try{eval(\"/(?<!foo)/\")}catch(a){Q=\"\"}})();const Z=/([^\\\\])(\\[\\^?)\\](\\]|.*[^\\\\]\\])/g,aa=/([^\\\\])({,|\\\\A|\\\\Z|\\$|\\(\\?P=([^\\d\\W]\\w*)\\)|\\(\\?P<([^\\d\\W]\\w*)>)(?!(?:\\]|[^\\[]*[^\\\\]\\]))/g,ba=/\\\\[\\t\\r\\n \\v\\f#&~\"'!:,;`<>]|\\\\-(?!(?:\\]|[^\\[]*[^\\\\]\\]))/g,ca=/Incomplete quantifier|Lone quantifier/g,B=Object.create(null);d.error=A(\"re.error\",{base:R,constructor:function(a,b,c){this.$pattern=b;this.$msg=a;this.$pos=c||q;R.call(this,a)},slots:{tp$doc:\"Exception raised for invalid regular expressions.\\n\\n    Attributes:\\n\\n        msg: The unformatted error message\\n        pattern: The regular expression pattern\\n\",\ntp$init(a,b){const [c,e,f]=ma(\"re.error\",[\"msg\",\"pattern\",\"pos\"],a,b,[q,q]);this.$pattern=e;this.$pos=f;this.$msg=c}},getsets:{msg:{$get(){return this.$msg}},pattern:{$get(){return this.$pattern}},pos:{$get(){return this.$pos}}}});const h=new l(0),w=Number.MAX_SAFE_INTEGER;d.Pattern=A(\"re.Pattern\",{constructor:function(a,b,c){this.v=a;this.str=b;this.$flags=c;this.$groupindex=this.$groups=null},slots:{$r(){const a=C(this.str).slice(0,200),b=C(this.$flags.nb$and(d.U.nb$invert()));return new k(\"re.compile(\"+\na+(b?\", \"+b:\"\")+\")\")},tp$richcompare(a,b){if(\"Eq\"!==b&&\"NotEq\"!==b||!(a instanceof d.Pattern))return M;a=this.str===a.str&&this.$flags===a.$flags;return\"Eq\"===b?a:!a},tp$hash(){},tp$doc:\"Compiled regular expression object.\"},methods:{match:{$meth:function(a,b,c){return this.$match(a,b,c)},$flags:{NamedArgs:[\"string\",\"pos\",\"endpos\"],Defaults:[h,w]},$textsig:\"($self, /, string, pos=0, endpos=sys.maxsize)\",$doc:\"Matches zero or more characters at the beginning of the string.\"},fullmatch:{$meth:function(a,\nb,c){return this.full$match(a,b,c)},$flags:{NamedArgs:[\"string\",\"pos\",\"endpos\"],Defaults:[h,w]},$textsig:\"($self, /, string, pos=0, endpos=sys.maxsize)\",$doc:\"Matches against all of the string.\"},search:{$meth:function(a,b,c){return this.$search(a,b,c)},$flags:{NamedArgs:[\"string\",\"pos\",\"endpos\"],Defaults:[h,w]},$textsig:\"($self, /, string, pos=0, endpos=sys.maxsize)\",$doc:\"Scan through string looking for a match, and return a corresponding match object instance.\\n\\nReturn None if no position in the string matches.\"},\nsub:{$meth:function(a,b,c){return this.$sub(a,b,c)},$flags:{NamedArgs:[\"repl\",\"string\",\"count\"],Defaults:[h]},$textsig:\"($self, /, repl, string, count=0)\",$doc:\"Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl.\"},subn:{$meth:function(a,b,c){return this.$subn(a,b,c)},$flags:{NamedArgs:[\"repl\",\"string\",\"count\"],Defaults:[h]},$textsig:\"($self, /, repl, string, count=0)\",$doc:\"Return the tuple (new_string, number_of_subs_made) found by replacing the leftmost non-overlapping occurrences of pattern with the replacement repl.\"},\nfindall:{$meth:function(a,b,c){return this.find$all(a,b,c)},$flags:{NamedArgs:[\"string\",\"pos\",\"endpos\"],Defaults:[h,w]},$textsig:\"($self, /, string, pos=0, endpos=sys.maxsize)\",$doc:\"Return a list of all non-overlapping matches of pattern in string.\"},split:{$meth:function(a,b){return this.$split(a,b)},$flags:{NamedArgs:[\"string\",\"maxsplit\"],Defaults:[h]},$textsig:\"($self, /, string, maxsplit=0)\",$doc:\"Split string by the occurrences of pattern.\"},finditer:{$meth:function(a,b,c){return this.find$iter(a,\nb,c)},$flags:{NamedArgs:[\"string\",\"pos\",\"endpos\"],Defaults:[h,w]},$textsig:\"($self, /, string, pos=0, endpos=sys.maxsize)\",$doc:\"Return an iterator over all non-overlapping matches for the RE pattern in string.\\n\\nFor each match, the iterator returns a match object.\"},scanner:{$meth:function(a,b,c){return this.$scanner(a,b,c)},$flags:{NamedArgs:[\"string\",\"pos\",\"endpos\"],Defaults:[h,w]},$textsig:\"($self, /, string, pos=0, endpos=sys.maxsize)\",$doc:null},__copy__:{$meth:function(){return this},$flags:{NoArgs:!0},\n$textsig:\"($self, /)\",$doc:null},__deepcopy__:{$meth:function(){return this},$flags:{OneArg:!0},$textsig:\"($self, memo, /)\",$doc:null}},getsets:{pattern:{$get(){return this.str},$doc:\"The pattern string from which the RE object was compiled.\"},flags:{$get(){return this.$flags},$doc:\"The regex matching flags.\"},groups:{$get(){if(null===this.$groups){const a=(this.str.v.match(this.group$regex)||[]).length;this.$groups=new l(a)}return this.$groups},$doc:\"The number of capturing groups in the pattern.\"},\ngroupindex:{$get(){if(null===this.$groupindex){const a=this.str.v.matchAll(this.group$regex),b=[];let c=1;for(const e of a)e[1]&&(b.push(new k(e[1])),b.push(new l(c))),c++;this.$groupindex=new ea(new H(b))}return this.$groupindex},$doc:\"A dictionary mapping group names to group numbers.\"}},proto:{group$regex:/\\((?!\\?(?!P<).*)(?:\\?P<([^\\d\\W]\\w*)>)?(?![^\\[]*\\])/g,get$count(a){return(a=J(a,ha))?a:Number.POSITIVE_INFINITY},get$jsstr(a,b,c){if(!y(a))throw new v(\"expected string or bytes-like object\");\nif(b===h&&c===w||void 0===b&&void 0===c)return{jsstr:a.toString(),pos:h.valueOf(),endpos:a.sq$length()};const {start:e,end:f}=fa.startEnd$wrt(a,b,c);return{jsstr:a.toString().slice(e,f),pos:e,endpos:f}},find$all(a,b,c){({jsstr:a}=this.get$jsstr(a,b,c));a=a.matchAll(this.v);b=[];for(let e of a)b.push(1===e.length?new k(e[0]):2===e.length?new k(e[1]):new u(e.slice(1).map(f=>new k(f))));return new I(b)},$split(a,b){b=(b=J(b))?b:Number.POSITIVE_INFINITY;({jsstr:a}=this.get$jsstr(a));const c=this.v,e=\n[];let f,g=0,n=0;for(;null!==(f=c.exec(a))&&g<b;)if(e.push(new k(a.substring(n,f.index))),1<f.length&&e.push(...f.slice(1).map(m=>void 0===m?q:new k(m))),g++,n=c.lastIndex,f.index===c.lastIndex)if(a)a=a.slice(f.index),n=0,c.lastIndex=1;else break;c.lastIndex=0;e.push(new k(a.slice(n)));return new I(e)},match$from_repl(a,b,c,e){let f;const g=a[a.length-1];\"object\"===typeof g?(f=a.slice(0,a.length-3),Object.assign(f,{groups:g}),f.index=a[a.length-3]):(f=a.slice(0,a.length-2),f.groups=void 0,f.index=\na[a.length-2]);return new d.Match(f,this.str,b,c,e)},do$sub(a,b,c){const {jsstr:e,pos:f,endpos:g}=this.get$jsstr(b);let n;ja(a)?n=p=>{p=pa(a,[p]);if(!y(p))throw new v(\"expected str instance, \"+z(p)+\" found\");return p.toString()}:(a=this.get$jsstr(a).jsstr,n=p=>p.template$repl(a));c=this.get$count(c);let m=0;const r=e.replace(this.v,(...p)=>{if(m>=c)return p[0];m++;p=this.match$from_repl(p,b,f,g);return n(p)});return[new k(r),new l(m)]},$sub(a,b,c){[a]=this.do$sub(a,b,c);return a},$subn(a,b,c){return new u(this.do$sub(a,\nb,c))},do$match(a,b,c,e){let f;({jsstr:f,pos:c,endpos:e}=this.get$jsstr(b,c,e));a=f.match(a);return null===a?q:new d.Match(a,this,b,c,e)},$search(a,b,c){var e=new RegExp(this.v.source,this.v.flags.replace(\"g\",\"\"));return this.do$match(e,a,b,c)},$match(a,b,c){let e=this.v.source,f=this.v.flags.replace(\"g\",\"\").replace(\"m\",\"\");return this.do$match(new RegExp(\"^\"+e,f),a,b,c)},full$match(a,b,c){let e=this.v.source,f=this.v.flags.replace(\"g\",\"\").replace(\"m\",\"\");return this.do$match(new RegExp(\"^(?:\"+e+\n\")$\",f),a,b,c)},find$iter(a,b,c){let e;({jsstr:e,pos:b,endpos:c}=this.get$jsstr(a,b,c));const f=e.matchAll(this.v);return new T(()=>{const g=f.next().value;if(void 0!==g)return new d.Match(g,this,a,b,c)})}},flags:{sk$unacceptableBase:!0}});d.Match=A(\"re.Match\",{constructor:function(a,b,c,e,f){this.v=a;this.$match=new k(this.v[0]);this.str=c;this.$re=b;this.$pos=e;this.$endpos=f;this.$regs=this.$lastgroup=this.$lastindex=this.$groups=this.$groupdict=null},slots:{tp$doc:\"The result of re.match() and re.search().\\nMatch objects always have a boolean value of True.\",\n$r(){let a;a=\"<re.Match object; span=(\"+(this.v.index+\", \"+(this.v.index+this.$match.sq$length())+\"), \");a+=\"match=\"+C(this.$match)+\">\";return new k(a)},tp$as_squence_or_mapping:!0,mp$subscript(a){a=this.get$group(a);return void 0===a?q:new k(a)}},methods:{group:{$meth:function(...a){let b;if(1>=a.length)return b=this.get$group(a[0]),void 0===b?q:new k(b);b=[];a.forEach(c=>{c=this.get$group(c);b.push(void 0===c?q:new k(c))});return new u(b)},$flags:{MinArgs:0},$textsig:null,$doc:\"group([group1, ...]) -> str or tuple.\\n    Return subgroup(s) of the match by indices or names.\\n    For 0 returns the entire match.\"},\nstart:{$meth:function(a){a=this.get$group(a);return void 0===a?new l(-1):new l(this.str.v.indexOf(a,this.v.index+this.$pos))},$flags:{MinArgs:0,MaxArgs:1},$textsig:\"($self, group=0, /)\",$doc:\"Return index of the start of the substring matched by group.\"},end:{$meth:function(a){a=this.get$group(a);return void 0===a?new l(-1):new l(this.str.v.indexOf(a,this.v.index+this.$pos)+[...a].length)},$flags:{MinArgs:0,MaxArgs:1},$textsig:\"($self, group=0, /)\",$doc:\"Return index of the end of the substring matched by group.\"},\nspan:{$meth:function(a){return this.$span(a)},$flags:{MinArgs:0,MaxArgs:1},$textsig:\"($self, group=0, /)\",$doc:\"For match object m, return the 2-tuple (m.start(group), m.end(group)).\"},groups:{$meth:function(a){if(null!==this.$groups)return this.$groups;this.$groups=Array.from(this.v.slice(1),b=>void 0===b?a:new k(b));return this.$groups=new u(this.$groups)},$flags:{NamedArgs:[\"default\"],Defaults:[q]},$textsig:\"($self, /, default=None)\",$doc:\"Return a tuple containing all the subgroups of the match, from 1.\\n\\n  default\\n    Is used for groups that did not participate in the match.\"},\ngroupdict:{$meth:function(a){if(null!==this.$groupdict)return this.$groupdict;if(void 0===this.v.groups)this.$groupdict=new H;else{const b=[];Object.entries(this.v.groups).forEach(([c,e])=>{b.push(new k(c));b.push(void 0===e?a:new k(e))});this.$groupdict=new H(b)}return this.$groupdict},$flags:{NamedArgs:[\"default\"],Defaults:[q]},$textsig:\"($self, /, default=None)\",$doc:\"Return a dictionary containing all the named subgroups of the match, keyed by the subgroup name.\\n\\n  default\\n    Is used for groups that did not participate in the match.\"},\nexpand:{$meth:function(a){if(!y(a))throw new v(\"expected str instance got \"+z(a));a=a.toString();a=this.template$repl(a);return new k(a)},$flags:{OneArg:!0},$textsig:\"($self, /, template)\",$doc:\"Return the string obtained by doing backslash substitution on the string template, as done by the sub() method.\"},__copy__:{$meth:function(){return this},$flags:{NoArgs:!0},$textsig:\"($self, /)\",$doc:null},__deepcopy__:{$meth:function(){return this},$flags:{OneArg:!0},$textsig:\"($self, memo, /)\",$doc:null}},\ngetsets:{lastindex:{$get(){if(null!==this.$lastindex)return this.$lastindex;let a=0,b;this.v.forEach((c,e)=>{e&&void 0!==c&&b!==c&&(a=e,b=c)});return this.$lastindex=a?new l(a):q},$doc:\"The integer index of the last matched capturing group.\"},lastgroup:{$get(){if(null!==this.$lastgroup)return this.$lastgroup;if(void 0===this.v.groups)this.$lastgroup=q;else{let a;Object.entries(this.v.groups).forEach(([b,c])=>{void 0!==c&&(a=b)});this.$lastgroup=void 0===a?q:new k(a)}return this.$lastgroup},$doc:\"The name of the last matched capturing group.\"},\nregs:{$get(){if(null!==this.$regs)return this.$regs;const a=[];this.v.forEach((b,c)=>{a.push(this.$span(c))});return this.$regs=new u(a)}},string:{$get(){return this.str},$doc:\"The string passed to match() or search().\"},re:{$get(){return this.$re},$doc:\"The regular expression object.\"},pos:{$get(){return new l(this.$pos)},$doc:\"The index into the string at which the RE engine started looking for a match.\"},endpos:{$get(){return new l(this.$endpos)},$doc:\"The index into the string beyond which the RE engine will not go.\"}},\nproto:{get$group(a){if(void 0===a)return this.v[0];if(y(a)){if(a=a.toString(),this.v.groups&&Object.prototype.hasOwnProperty.call(this.v.groups,a))return this.v.groups[a]}else if(oa(a)&&(a=J(a),0<=a&&a<this.v.length))return this.v[a];throw new S(\"no such group\");},$span(a){a=this.get$group(a);if(void 0===a)return new u([new l(-1),new l(-1)]);let b;if(\"\"===a&&\"\"===this.v[0])return b=new l(this.v.index),new u([b,b]);b=this.str.v.indexOf(a,this.v.index+this.$pos);return new u([new l(b),new l(b+[...a].length)])},\nhasOwnProperty:Object.prototype.hasOwnProperty,template$regex:/\\\\([1-9][0-9]|[1-9])|\\\\g<([1-9][0-9]*)>|\\\\g<([^\\d\\W]\\w*)>|\\\\g<?.*>?/g,template$repl(a){return a.replace(this.template$regex,(b,c,e,f,g,n)=>{let m;c=c||e;void 0!==c?m=c<this.v.length?this.v[c]||\"\":void 0:this.v.groups&&this.hasOwnProperty.call(this.v.groups,f)&&(m=this.v.groups[f]||\"\");if(void 0===m){if(f)throw new S(\"unknown group name '\"+f+\"'\");throw new d.error(\"invalid group reference \"+(c||b.slice(2))+\" at position \"+(g+1));}return m})}},\nflags:{sk$unacceptableBase:!0}});na(\"re\",d,{match:{$meth:function(a,b,c){return t(a,c).$match(b)},$flags:{NamedArgs:[\"pattern\",\"string\",\"flags\"],Defaults:[h]},$textsig:\"($module, / , pattern, string, flags=0)\",$doc:\"Try to apply the pattern at the start of the string, returning\\n    a Match object, or None if no match was found.\"},fullmatch:{$meth:function(a,b,c){return t(a,c).full$match(b)},$flags:{NamedArgs:[\"pattern\",\"string\",\"flags\"],Defaults:[h]},$textsig:\"($module, / , pattern, string, flags=0)\",\n$doc:\"Try to apply the pattern to all of the string, returning\\n    a Match object, or None if no match was found.\"},search:{$meth:function(a,b,c){return t(a,c).$search(b)},$flags:{NamedArgs:[\"pattern\",\"string\",\"flags\"],Defaults:[h]},$textsig:\"($module, / , pattern, string, flags=0)\",$doc:\"Scan through string looking for a match to the pattern, returning\\n    a Match object, or None if no match was found.\"},sub:{$meth:function(a,b,c,e,f){return t(a,f).$sub(b,c,e)},$flags:{NamedArgs:[\"pattern\",\"repl\",\n\"string\",\"count\",\"flags\"],Defaults:[h,h]},$textsig:\"($module, / , pattern, string, count=0, flags=0)\",$doc:\"Return the string obtained by replacing the leftmost\\n    non-overlapping occurrences of the pattern in string by the\\n    replacement repl.  repl can be either a string or a callable;\\n    if a string, backslash escapes in it are processed.  If it is\\n    a callable, it's passed the Match object and must return\\n    a replacement string to be used.\"},subn:{$meth:function(a,b,c,e,f){return t(a,\nf).$subn(b,c,e)},$flags:{NamedArgs:[\"pattern\",\"repl\",\"string\",\"count\",\"flags\"],Defaults:[h,h]},$textsig:\"($module, / , pattern, string, count=0, flags=0)\",$doc:\"Return a 2-tuple containing (new_string, number).\\n    new_string is the string obtained by replacing the leftmost\\n    non-overlapping occurrences of the pattern in the source\\n    string by the replacement repl.  number is the number of\\n    substitutions that were made. repl can be either a string or a\\n    callable; if a string, backslash escapes in it are processed.\\n    If it is a callable, it's passed the Match object and must\\n    return a replacement string to be used.\"},\nsplit:{$meth:function(a,b,c,e){return t(a,e).$split(b,c)},$flags:{NamedArgs:[\"pattern\",\"string\",\"maxsplit\",\"flags\"],Defaults:[h,h]},$textsig:\"($module, / , pattern, string, maxsplit=0, flags=0)\",$doc:\"Split the source string by the occurrences of the pattern,\\n    returning a list containing the resulting substrings.  If\\n    capturing parentheses are used in pattern, then the text of all\\n    groups in the pattern are also returned as part of the resulting\\n    list.  If maxsplit is nonzero, at most maxsplit splits occur,\\n    and the remainder of the string is returned as the final element\\n    of the list.\"},\nfindall:{$meth:function(a,b,c){return t(a,c).find$all(b)},$flags:{NamedArgs:[\"pattern\",\"string\",\"flags\"],Defaults:[h]},$textsig:\"($module, / , pattern, string, flags=0)\",$doc:\"Return a list of all non-overlapping matches in the string.\\n\\n    If one or more capturing groups are present in the pattern, return\\n    a list of groups; this will be a list of tuples if the pattern\\n    has more than one group.\\n\\n    Empty matches are included in the result.\"},finditer:{$meth:function(a,b,c){return t(a,\nc).find$iter(b)},$flags:{NamedArgs:[\"pattern\",\"string\",\"flags\"],Defaults:[h]},$textsig:\"($module, / , pattern, string, flags=0)\",$doc:\"Return an iterator over all non-overlapping matches in the\\n    string.  For each match, the iterator returns a Match object.\\n\\n    Empty matches are included in the result.\"},compile:{$meth:function(a,b){return t(a,b)},$flags:{NamedArgs:[\"pattern\",\"flags\"],Defaults:[h]},$textsig:\"($module, / , pattern, flags=0)\",$doc:\"Compile a regular expression pattern, returning a Pattern object.\"},\npurge:{$meth:function(){Object.keys(B).forEach(a=>{delete B[a]});return q},$flags:{NoArgs:!0},$textsig:\"($module, / )\",$doc:\"Clear the regular expression caches\"},template:{$meth:function(a,b){return t(a,x(d.T,b,\"BitOr\"))},$flags:{NamedArgs:[\"pattern\",\"flags\"],Defaults:[h]},$textsig:\"($module, / , pattern, flags=0)\",$doc:\"Compile a template pattern, returning a Pattern object\"},escape:{$meth:function(a){if(!y(a))throw new v(\"expected a str instances, got \"+z(a));a=a.toString();a=a.replace(qa,\"\\\\$&\");\nreturn new k(a)},$flags:{NamedArgs:[\"pattern\"],Defaults:[]},$textsig:\"($module, / , pattern)\",$doc:\"\\n    Escape special characters in a string.\\n    \"}});const qa=/[&~#.*+\\-?^${}()|[\\]\\\\\\t\\r\\v\\f\\n ]/g;return d};\n",
  "src/lib/string.js": "'use strict';var $builtinmodule=function(h){var a={};a.ascii_lowercase=new Sk.builtin.str(\"abcdefghijklmnopqrstuvwxyz\");a.ascii_uppercase=new Sk.builtin.str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");a.ascii_letters=new Sk.builtin.str(a.ascii_lowercase.v+a.ascii_uppercase.v);a.lowercase=new Sk.builtin.str(\"abcdefghijklmnopqrstuvwxyz\");a.uppercase=new Sk.builtin.str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");a.letters=new Sk.builtin.str(a.lowercase.v+a.uppercase.v);a.digits=new Sk.builtin.str(\"0123456789\");a.hexdigits=new Sk.builtin.str(\"0123456789abcdefABCDEF\");\na.octdigits=new Sk.builtin.str(\"01234567\");a.punctuation=new Sk.builtin.str(\"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\");a.whitespace=new Sk.builtin.str(\"\\t\\n\\x0B\\f\\r \");a.printable=new Sk.builtin.str(a.digits.v+a.letters.v+a.punctuation.v+\" \\t\\n\\r\\x0B\\f\");a.split=new Sk.builtin.func(function(...c){return Sk.misceval.callsimArray(Sk.builtin.str.prototype.split,c)});a.capitalize=new Sk.builtin.func(function(c){return Sk.misceval.callsimArray(Sk.builtin.str.prototype.capitalize,[c])});a.join=new Sk.builtin.func(function(c,\nb){void 0===b&&(b=new Sk.builtin.str(\" \"));return Sk.misceval.callsimArray(Sk.builtin.str.prototype.join,[b,c])});a.capwords=new Sk.builtin.func(function(c,b){Sk.builtin.pyCheckArgsLen(\"capwords\",arguments.length,1,2);if(!Sk.builtin.checkString(c))throw new Sk.builtin.TypeError(\"s must be a string\");void 0===b&&(b=new Sk.builtin.str(\" \"));if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"sep must be a string\");for(var e=Sk.misceval.callsimArray(a.split,[c,b]).v,f=[],d=0;d<e.length;d++){var g=\nSk.misceval.callsimArray(a.capitalize,[e[d]]);f.push(g)}return Sk.misceval.callsimArray(a.join,[new Sk.builtin.list(f),b])});return a};\n",
  "src/lib/uuid.js": "'use strict';function $builtinmodule(){function d(){throw new u(\"Not yet implemneted in Skulpt\");}function v(a){const b=new Uint8Array(a);b[0]=a[3];b[1]=a[2];b[2]=a[1];b[3]=a[0];b[4]=a[5];b[5]=a[4];b[6]=a[7];b[7]=a[6];return b}const {builtin:{bytes:m,str:f,int_:g,TypeError:q,ValueError:n,NotImplementedError:u,none:{none$:c},NotImplemented:{NotImplemented$:C}},abstr:{buildNativeClass:D,checkArgsLen:E,copyKeywordsToNamedArgs:F,lookupSpecial:G,setUpModuleMethods:H},misceval:{callsimArray:p,objectRepr:I,\nrichCompareBool:w}}=Sk,r={__name__:new f(\"uuid\"),RESERVED_NCS:c,RFC_4122:c,RESERVED_FUTURE:c};let t=Sk.global.crypto;\"undefined\"===typeof t&&(t={getRandomValues(a){let b=a.length;for(;b--;)a[b]=Math.floor(256*Math.random());return a}});const J=g.tp$getattr(new f(\"from_bytes\")),K=g.tp$getattr(new f(\"to_bytes\")),L=(new g(1)).nb$lshift(new g(128)),M=new g(0),N=new g(4),x=new g(16),y=new f(\"big\"),z=new f(\"%032x\"),O=/-/g,B=r.UUID=D(\"uuid.UUID\",{constructor:function(){},slots:{tp$init(a,b){E(\"UUID\",a,0,\n6);let [e,h,k,A,l,,P]=F(\"UUID\",\"hex bytes bytes_le fields int version is_safe\".split(\" \"),a,b,[c,c,c,c,c,c,c]);if(4!==[e,h,k,A,l].filter(Q=>Q===c).length)throw new q(\"one of the hex, bytes, bytes_le, fields, or int arguments must be given\");if(e!==c){e=e.toString().replace(\"urn:\",\"\").replace(\"uuid:\",\"\");a=0;for(b=e.length-1;0<=\"{}\".indexOf(e[a]);)a++;for(;0<=\"{}\".indexOf(e[b]);)b--;e=e.slice(a,b+1);e=e.replace(O,\"\");if(32!==e.length)throw new n(\"badly formed hexadecimal UUID string\");l=p(g,[new f(e),\nx])}if(k!==c){if(!(k instanceof m))throw new q(\"bytes_le should be a bytes instance\");k=k.valueOf();if(16!==k.length)throw new n(\"bytes_le is not a 16-char string\");h=v(k);h=new m(h)}if(h!==c){if(!(h instanceof m))throw new q(\"bytes_le should be a bytes instance\");if(16!==h.valueOf().length)throw new n(\"bytes is not a 16-char string\");l=p(J,[h],[\"byteorder\",y])}if(A!==c)throw new u(\"fields argument is not yet supported\");if(l!==c&&(w(l,M,\"Lt\")||w(l,L,\"GtE\")))throw new n(\"int is out of range (need a 128-bit value)\");\nthis.$int=l;this.$isSafe=P},tp$str(){const a=z.nb$remainder(this.$int).toString();return new f(`${a.slice(0,8)}-${a.slice(8,12)}-${a.slice(12,16)}-${a.slice(16,20)}-${a.slice(20)}`)},$r(){const a=G(this.ob$type,f.$name),b=I(this.tp$str());return new f(`${a}(${b})`)},tp$hash(){return this.$int.tp$hash()},tp$richcompare(a,b){return a instanceof B?this.$int.tp$richcompare(a.$int,b):C},tp$as_number:!0,nb$int(){return this.$int}},getsets:{int:{$get(){return this.$int}},is_safe:{$get(){return this.$isSafe}},\nbytes:{$get(){return p(K,[this.$int,x,y])}},bytes_le:{$get(){const a=this.tp$getattr(new f(\"bytes\")).valueOf();return new m(v(a))}},fields:{$get(){return d()}},time_low:{$get(){return d()}},time_mid:{$get(){return d()}},time_hi_version:{$get(){return d()}},clock_seq_hi_variant:{$get(){return d()}},clock_seq_low:{$get(){return d()}},time:{$get(){return d()}},clock_seq:{$get(){return d()}},node:{$get(){return d()}},hex:{$get(){return z.nb$remainder(this.$int)}},urn:{$get(){return new f(`urn:uuid:${this}`)}},\nvariant:{$get(){return d()}},version:{$get(){return d()}}}});H(\"uuid\",r,{uuid1:{$meth(){d()},$flags:{FastCall:!0}},uuid2:{$meth(){d()},$flags:{FastCall:!0}},uuid3:{$meth(){d()},$flags:{FastCall:!0}},uuid4:{$meth(){const a=new m(t.getRandomValues(new Uint8Array(16)));return p(B,[],[\"bytes\",a,\"version\",N])},$flags:{NoArgs:!0}},uuid5:{$meth(){d()},$flags:{FastCall:!0}}});return r};\n"
}